---
title: "An application: SLGP-based prediction of temperature distributions at meteorological stations in Switzerland."
author: "Athénaïs Gautier"
date: "Last revised - October 2024"
output:
  html_document:
  #bookdown::pdf_document2 :
  #  keep_tex: false
  #  toc: false
  #  number_sections: true
    citation_package: natbib
bibliography: references.bib
header-includes:
 \usepackage{float}
 \usepackage{tikz}
 \usepackage{xcolor}
 \usepackage{amsmath, amsfonts, amsthm}
 \floatplacement{figure}{H}
 \usepackage{fvextra}
 \DefineVerbatimEnvironment{Highlighting}{Verbatim}{breaklines,commandchars=\\\{\}}

---

\newcommand{\xX}{\mathbf{x}}
\newcommand{\xI}{\mathcal{T}}
\newcommand{\xR}{\mathbb{R}}
\newcommand{\dimI}{d_\xI}
\newcommand{\dimD}{d_D}
\newcommand{\dxx}{d_{\xX, \xX'}}
\newcommand{\kincrement}{k_{\text{inc}}}
\newcommand{\mincrement}{m_{\text{inc}}}
\newcommand{\xM}{M(\xX, \xX')}
\newcommand{\diam}{D_{\xX, \xX'}(\xI)}
\newcommand{\xY}{\Vert \xX - \xX' \Vert^{\alpha_1 /2}}
\newcommand{\sigFieldM}{\mathcal{B}(\xI)}

\newcommand{\proc}[3]{
\ifstrempty{#3}%
{%
\ifstrempty{#2}%
{%
#1
}{%
#1_{#2}
}%
}{%
(#1_{#2})_{#3}
}%
}

```{r loadlibs, setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(ggplot2)
library(viridis)
```

## Introduction

In this vignette, we apply the Spatial Logistic Gaussian Process (SLGP) model to estimate temperature distributions at meteorological stations across Switzerland. This example illustrates SLGP's capacity to model spatial temperature variations based on location-specific factors, such as latitude, longitude, and altitude, using real meteorological data made available by MeteoSwiss [@meteorology_climatological_2019].

## Data Loading and Visualization

We begin by loading and visualizing the dataset of daily average temperatures at 29 meteorological stations across Switzerland. This initial step provides insight into temperature variability across different regions and altitudes.

```{r dataset}
# Dataset
X <- read.csv("./data_meteo.txt", encoding = "latin1")
stations <- unique(X[, c(1, 8:13)])

world_map <- map_data("world", region="Switzerland") #Load a map
```

```{r topography, fig.fullwidth=TRUE, fig.height=5,fig.pos="H", warning=FALSE, message=FALSE, include=FALSE}
load(file="topography.RData")
switzerland <- ggplot() + 
  geom_raster(topography, mapping=aes(x=long, y=lat, fill=h*0), fill="white") +
  geom_raster(topography, mapping=aes(x=long, y=lat, fill=h), alpha=0.5) +
  theme_void()+
  theme(legend.position="bottom", 
        legend.box = "horizontal") +
  scale_fill_viridis(option = "turbo", direction = +1, 
                     name="Elevation [m]",
                     guide = guide_colorbar(
                       direction = "horizontal",
                       barheight = unit(2, units = "mm"),
                       barwidth = unit(50, units = "mm"),
                       draw.ulim = F,
                       title.position = 'top',
                       # some shifting around
                       title.hjust = 0.5,
                       label.hjust = 0.5
                     ))+ 
  xlab("Longitude") + ylab("Latitude") 
```

```{r mapplot1, include=FALSE, fig.cap="Meteorological stations where measurements are available"}
library(ggrepel)
plot_map <-switzerland+
  # theme_classic()+
  geom_point(data=stations, mapping = aes(x=Longitude, y=Latitude)) +
  geom_label_repel(data=stations,
                   aes(x = Longitude, y = Latitude, label=Station),
                   size=3, alpha=0.9, 
                   point.padding = 0., 
                   nudge_x = .25,
                   nudge_y = .25,
                   segment.curvature = -1e-20)+
  theme(plot.title=element_text(size=10, hjust = 0.5))
plot_map
ggsave("./figures/map_switzerland.png", width=6, height=3.5)
ggsave("./figures/map_switzerland.pdf", width=6, height=3.5)
```

To ensure a smooth modeling process, we prepare the dataset by renaming variables for clarity and storing their respective value ranges. This step facilitates easier handling of variables in subsequent modeling steps.

```{r startinit}
#Ready to normalise
range_temp <- c(-30, 40)
range_lat <- range(world_map$lat)
range_long <- range(world_map$long)
range_height <- c(0, 4810)

#Extract the relevant columns
samples <- X[, c("tre200d0", "Latitude", "Longitude", "Station.height.m..a..sea.level")]
colnames(samples) <- c("Temperature", "Latitude", "Longitude", "Altitude")
summary(samples)
```

We will use data from stations outside the canton of Bern for training the SLGP model, leaving the remaining stations as a test set to assess generalization. The model will predict temperature distributions based on the latitude, longitude, and altitude of each station.

```{r plotdensities, fig.fullwidth=TRUE, fig.height=5,fig.pos="H", warning=FALSE, message=FALSE}
plotDensities <- merge(samples, stations[, c(2, 4, 5, 7)]) %>%
  mutate(inCantonBE = Canton=="BE")%>%
  ggplot()+  
  geom_histogram(mapping=aes(x=Temperature, y=after_stat(density), col=inCantonBE, fill=inCantonBE), 
                 breaks = seq(-30, 40, 2.5), alpha=0.2)+
  geom_density(mapping=aes(x=Temperature, col=inCantonBE))+
  scale_color_manual(values=c("darkgrey", "cornflowerblue"))+
  scale_fill_manual(values=c("darkgrey", "cornflowerblue"))+
  facet_wrap(Station~.)+
  theme_bw() +
  theme(legend.position = "bottom")+
  labs(title = "Temperature distribution by station.",
       subtitle = "Histograms and pointwise kernel density estimators (grey for the train set, blue for the test).",
       x = "Temperature (°C)",
       y = "Density",
       color = "Station in the canton of Bern",
       fill = "Station in the canton of Bern")
plotDensities
```

## Initial SLGP Estimation with Arbitrary Hyperparameters


To understand the model's baseline behavior, we perform an initial SLGP estimation using arbitrary hyperparameters. This first run provides insight into the model’s ability to capture the temperature distribution’s overall structure.

```{r SLGPtoobig, fig.fullwidth=TRUE, fig.height=8, fig.width=10, fig.pos="H", warning=FALSE, message=FALSE}
library(SLGP)
samples <- merge(samples, stations[, c(2, 4, 5, 7)]) %>%
  mutate(inCantonBE = Canton=="BE")

model1 <- slgp(Temperature~.,
               data=samples[!samples$inCantonBE, 1:4],
               method="MAP",
               basisFunctionsUsed = "RFF",
               interpolateBasisFun="nothing",
               hyperparams = list(lengthscale=rep(0.3, 4), 
                                  sigma2=1),
               predictorsUpper= c(range_lat[2], 
                                  range_long[2], 
                                  range_height[2]),
               predictorsLower= c(range_lat[1], 
                                  range_long[1], 
                                  range_height[1]),
               responseRange= range_temp,
               sigmaEstimationMethod = "heuristic",
               seed=1,
               opts_BasisFun = list(nFreq=250,
                                    MatParam=5/2))
dfGrid <- expand.grid(seq(-30, 40,, 1001), seq(nrow(stations)))
dfGrid <- cbind(dfGrid[, 1], stations[dfGrid[, 2], c(4, 5, 3)])
colnames(dfGrid) <- c("Temperature", "Latitude", "Longitude", "Altitude")
pred <- predictSLGP_newNode(SLGPmodel=model1,
                            newNodes = dfGrid)
pred <- merge(pred, stations[, c(2, 4, 5, 7)]) %>%
  mutate(inCantonBE = Canton=="BE")

plotDensities + 
  geom_line(data = pred, mapping=aes(x=Temperature, y=pdf_1),
            col="red")+
  labs(title = "Temperature distribution by station.",
       subtitle = "Histograms and pointwise kernel density estimators 
       (grey for the train set, blue for the test),
       \nSLGP MAP estimator with poorly chosen hyperparameters (red curves).")
```

The initial results show that while the model captures the general support of the temperature distribution, it fails to capture finer details, such as multi-modalities in certain distributions. This limitation likely arises from using a large length scale, which oversmooths small-scale variations.

To investigate further, we run the SLGP with a much smaller length scale. This adjustment helps reveal the model’s response to hyperparameter tuning and allows us to compare results across different spatial aggregation levels.


```{r SLGPtoosmall, fig.fullwidth=TRUE,  fig.height=8, fig.width=10, fig.pos="H", warning=FALSE, message=FALSE}
model2 <- slgp(Temperature~.,
               data=samples[!samples$inCantonBE, 1:4],
               method="MAP",
               basisFunctionsUsed = "RFF",
               interpolateBasisFun="nothing",
               hyperparams = list(lengthscale=rep(0.05, 4), 
                                  sigma2=1),
               predictorsUpper= c(range_lat[2], 
                                  range_long[2], 
                                  range_height[2]),
               predictorsLower= c(range_lat[1], 
                                  range_long[1], 
                                  range_height[1]),
               responseRange= range_temp,
               sigmaEstimationMethod = "heuristic",
               seed=1,
               opts_BasisFun = list(nFreq=250,
                                    MatParam=5/2))
pred <- predictSLGP_newNode(SLGPmodel=model2,
                            newNodes = dfGrid)
pred <- merge(pred, stations[, c(2, 4, 5, 7)]) %>%
  mutate(inCantonBE = Canton=="BE")

plotDensities + 
  geom_line(data = pred, mapping=aes(x=Temperature, y=pdf_1),
            col="red")+
  labs(title = "Temperature distribution by station.",
       subtitle = "Histograms and pointwise kernel density estimators 
       (grey for the train set, blue for the test),
       \nSLGP MAP estimator with poorly chosen hyperparameters (red curves).")
```

This time, while the model provides accurate temperature estimates at stations within the training set, it generalizes poorly to test stations. Using too small a length scale restricts the model’s spatial aggregation, limiting the reach of spatial information to a very local scope.

## Selecting an Optimal Length Scale with Grid Search

To balance between overly small and overly large length scales, we propose selecting an appropriate length-scale hyperparameter via a grid search, aiming to find a balanced length scale that performs well across different spatial contexts. This grid search involves computing the (unnormalized) posterior for various candidate length scales, and selecting the hyperparameter value that maximizes it. This approach seeks a compromise between the previously observed limitations: length scales that are too small, which limit spatial aggregation, and those that are too large, which oversmooth local variations.

In Switzerland, we expect altitude to be the most significant factor influencing temperature variation, often more so than latitude and longitude. Consequently, we opted to share a single length scale for latitude and longitude, thereby slightly reducing the computational cost of estimation and simplifying the visualization of the results. For clarity, the code presented here is structured as a single loop; however, in practical applications, we parallelized the computations to improve efficiency.

```{r CV, eval=FALSE}
dinvgamma <- function(x, alpha=3, beta=0.3) {
  ifelse(x<=0, 0, (beta^alpha / gamma(alpha)) * x^(-alpha - 1) * exp(-beta / x))
}

df_res <- data.frame(lt=NA, lx1=NA, lx2=NA, lx3=NA, value=NA)[c(0), ]
for(lx1 in seq(0.05, 0.5, 0.05)){
  lx2 <- lx1
  for(lx3 in seq(0.05, 0.5, 0.05)){
    for(lt in  seq(0.05, 0.3, 0.025)){
      starting_lengthscale <- c(lt, lx1, lx2, lx3)
      names(starting_lengthscale) <- paste0("Lengthscale ", c("t", name_index))
      print(starting_lengthscale)
      
      mod <- slgp(Temperature~.,
                  data=samplesTrain,
                  method="MAP",
                  basisFunctionsUsed = "RFF",
                  interpolateBasisFun="nothing",
                  hyperparams = list(lengthscale=starting_lengthscale,
                                     sigma2=1),
                  predictorsUpper= c(range_lat[2],
                                     range_long[2],
                                     range_height[2]),
                  predictorsLower= c(range_lat[1],
                                     range_long[1],
                                     range_height[1]),
                  responseRange= range_temp,
                  sigmaEstimationMethod = "heuristic",
                  seed=1,
                  opts_BasisFun = list(nFreq=250,
                                       MatParam=5/2))
      pred <- predictSLGP_newNode(SLGPmodel=mod,
                                  newNodes = samplesTest)
      logprior <- log(dinvgamma(lx1))+log(dinvgamma(lx2))+log(dinvgamma(lx3))+log(dinvgamma(lt))
      df_res <- rbind(dfres, c(starting_lengthscale, -sum(log(pred$pdf_1))-logprior))
    }
  }
}
save(df_res, file="resultsMeteo.RData" )
```

We can now display the resulting optimisation profile. 

```{r include=FALSE}
library(scales)
load(file="resultsMeteo.RData" )
best_value <- range(df_res$value)

# Only display a subplot, for compacity purposes
ind <- df_res$`Lengthscale t` <= 0.3 &
  df_res$`Lengthscale x3`<= 0.25 &
  df_res$`Lengthscale x1`<= 0.5 &
  df_res$`Lengthscale x1`>= 0.25


df_res <- df_res[ind, ]
df_res <- df_res %>%
  mutate(`Lengthscale t`=`Lengthscale t`*100)%>%
  mutate(`Lengthscale x1`=ifelse(`Lengthscale x1`==0.05,
                                 paste0("Latitude\nlongitude\n05% of range"),
                                 paste0("Latitude\nlongitude\n", `Lengthscale x1`*100, "% of range")))%>%
  mutate(`Lengthscale x3`=ifelse(`Lengthscale x3`==0.05,
                                 paste0("Altitude\n05% of range"),
                                 paste0("Altitude\n", `Lengthscale x3`*100, "% of range")))%>%
  group_by_at(paste0("Lengthscale x", seq(3)))%>%
  mutate(gives_min=any(value==best_value[1]))%>%
  mutate(to1percentmin=any(value<=0.99*best_value[1]))%>%
  ungroup()

list_lx <- seq(0.05, 0.5, 0.05)
list_lt <- seq(0.05, 0.3, 0.025)
df_res %>%
  ggplot(aes(x=`Lengthscale t`, y=value))+
  geom_line()+
  geom_rect(data = subset(df_res, to1percentmin&!gives_min&`Lengthscale t`==10), 
            fill = "cornflowerblue", col="blue", lty=2,
            alpha=0.1,
            xmin = 100*(list_lt[1]-diff(range(list_lt))*10.04), 
            xmax = 100*(list_lt[length(list_lt)]+diff(range(list_lt))*10.04),
            ymin = 1*(best_value[1]-diff(best_value)*10.03), 
            ymax = 1*(best_value[2]+diff(best_value)*10.03))+
  geom_rect(data = subset(df_res, gives_min), 
            fill = "green", alpha=0.01,
            colour = "forestgreen", lty=1,
            xmin = 100*(list_lt[1]-diff(range(list_lt))*10.04), 
            xmax = 100*(list_lt[length(list_lt)]+diff(range(list_lt))*10.04),
            ymin = 1*(best_value[1]-diff(best_value)*10.03), 
            ymax = 1*(best_value[2]+diff(best_value)*10.03))+
  facet_grid(`Lengthscale x3`~`Lengthscale x1`)+
  theme_bw()+
  geom_hline(yintercept=min(df_res$value), col="grey")+
  xlab("Lengthscale for Temperature (in % of range)")+
  ylab("Negative log-posterior")+ 
  scale_y_continuous(labels = scientific)
```

Using the optimal length scale hyperparameter identified in the grid search, we perform the final SLGP estimation. This provides the best compromise between local accuracy and generalization, as shown by improved prediction results at the test stations.

```{r SLGPgood, fig.fullwidth=TRUE, fig.height=5,fig.pos="H", warning=FALSE, message=FALSE, eval=FALSE}
load(file="resultsMeteo.RData" )

lengthscale <- as.numeric(df_res[which.min(df_res$value), 1:4])
model3 <- slgp(Temperature~.,
               data=samples[!samples$inCantonBE, 1:4],
               method="MCMC",
               basisFunctionsUsed = "RFF",
               interpolateBasisFun="nothing",
               hyperparams = list(lengthscale=lengthscale, 
                                  sigma2=1),
               predictorsUpper= c(range_lat[2], 
                                  range_long[2], 
                                  range_height[2]),
               predictorsLower= c(range_lat[1], 
                                  range_long[1], 
                                  range_height[1]),
               responseRange= range_temp,
               sigmaEstimationMethod = "heuristic",
               seed=1,
               opts_BasisFun = list(nFreq=250,
                                    MatParam=5/2),
               opts = list(stan_chains=2, stan_iter=1000))
model3MAP <- slgp(Temperature~.,
                  data=samples[!samples$inCantonBE, 1:4],
                  method="MAP",
                  basisFunctionsUsed = "RFF",
                  interpolateBasisFun="nothing",
                  hyperparams = list(lengthscale=lengthscale, 
                                     sigma2=1),
                  predictorsUpper= c(range_lat[2], 
                                     range_long[2], 
                                     range_height[2]),
                  predictorsLower= c(range_lat[1], 
                                     range_long[1], 
                                     range_height[1]),
                  responseRange= range_temp,
                  sigmaEstimationMethod = "heuristic",
                  seed=1,
                  opts_BasisFun = list(nFreq=250,
                                       MatParam=5/2),
                  opts = list(stan_chains=2, stan_iter=1000))
save(model3, model3MAP, file="ModelOptimizedLen.RData")
```

```{r SLGPgood2, fig.fullwidth=TRUE, fig.height=8, fig.width=10, fig.pos="H", warning=FALSE, message=FALSE}
load(file="ModelOptimizedLen.RData")

predMCMC <- predictSLGP_newNode(SLGPmodel=model3,
                                newNodes = dfGrid)
predMAP <- predictSLGP_newNode(SLGPmodel=model3MAP,
                               newNodes = dfGrid)
predMCMC$mean_pdf <- rowMeans(predMCMC[, -c(1:4)])

predMCMC <- merge(predMCMC, stations[, c(2, 4, 5, 7)]) %>%
  mutate(inCantonBE = Canton=="BE")
predMAP <- merge(predMAP, stations[, c(2, 4, 5, 7)]) %>%
  mutate(inCantonBE = Canton=="BE")
predMCMC2 <- predMCMC[, c(1:(4+100), 1005:1008)]%>%
  dplyr::select(Latitude | Longitude | Altitude | 
                  Temperature | starts_with("pdf") | Station)%>%
  pivot_longer(-c("Temperature", "Latitude", "Longitude", "Altitude", "Station"))%>%
  mutate(name=as.numeric(substr(name, 5, 11)))

plotDensities + 
  geom_line(data = predMCMC, mapping=aes(x=Temperature, y=pdf_1),
            col="black", lwd=0.1)+
  geom_line(data = predMCMC, mapping=aes(x=Temperature, y=pdf_201),
            col="black", lwd=0.1)+
  geom_line(data = predMCMC, mapping=aes(x=Temperature, y=pdf_401),
            col="black", lwd=0.1)+
  geom_line(data = predMCMC, mapping=aes(x=Temperature, y=pdf_601),
            col="black", lwd=0.1)+
  geom_line(data = predMCMC, mapping=aes(x=Temperature, y=pdf_801),
            col="black", lwd=0.1)+
  geom_line(data = predMCMC, mapping=aes(x=Temperature, y=mean_pdf),
            col="red")+
  labs(title = "Temperature distribution by station.",
       subtitle = "Histograms and pointwise kernel density estimators 
       (grey for the train set, blue for the test),
       \nSLGP MCMC estimators with optimally chosen hyperparameters (draws in black, mean in red).")
```
## Visualising results at some stations

```{r}

mock_df <- data.frame(x=c(rep(-1000, 3), rep(-2000, 3)),
                      y=0, curve=rep(c("MAP estimate", "MCMC draws", "MCMC mean"), 2))
Lin <- list()
samples$station <- X$Station
for(i in seq(nrow(stations))){
  Lin[[i]]<-list()
  Lin[[i]][["histogram"]] <- ggplot(X[X$Station==stations$Station[i], ])+
    theme_bw()+
    geom_histogram(mapping=aes(x=tre200d0,
                               y=..density..),
                   col="grey70", fill="grey95", linewidth=0.5, 
                   breaks=seq(range_temp[1], range_temp[2], 2))+
    coord_cartesian(xlim=range_temp, ylim=c(0, 0.07))+
    xlab("Temperature value [°C]")+
    ylab("Temperature distribution\n(marginalized over time)")+
    ggtitle(paste0(stations$Station[i], " (", 
                   stations$Station.height.m..a..sea.level[i],
                   "m)")) + 
    theme(plot.title=element_text(size=10, hjust = 0.5))
  ind_MAP <- predMAP$Station==stations$Station[i]
  ind_MCMC <- predMCMC$Station==stations$Station[i]
  ind_MCMC2 <- predMCMC2$Station==stations$Station[i] & predMCMC2$name %in% c(1)
  Lin[[i]][["data"]]<- ggplot(mock_df, mapping=aes(x=x, y=y, 
                                                   lty=curve, col=curve, alpha=curve))+
    coord_cartesian(xlim=range_temp, ylim=c(0, 0.07))+
    geom_line()+
    theme_bw()+
    geom_histogram(data=X[X$Station==stations$Station[i], ],
                   inherit.aes=FALSE,
                   mapping=aes(x=tre200d0,
                               y=..density..), col="midnightblue",  fill="lightsteelblue", 
                   alpha=0.1,
                   breaks=seq(range_temp[1], range_temp[2], 2))+
    geom_line(data=predMCMC2[ind_MCMC2, ],
              mapping=aes(x=Temperature, y=value, group=name),
                   inherit.aes=FALSE, alpha=0.5)+
    # geom_line(data=data.frame(x=predMCMC2$Temperature[ind_MCMC2],
    #                           y=predMCMC2$value[ind_MCMC2],
    #                           id=predMCMC2$name[ind_MCMC2], 
    #                           curve=mock_df$curve[2]), mapping=aes(group=id), alpha=0.5)+
    # geom_line(data=data.frame(x=predMAP$Temperature[ind_MAP],
    #                           y=predMAP$pdf_1[ind_MAP],
    #                           curve=mock_df$curve[1]), lwd=1)+
    # geom_line(data=data.frame(x=predMCMC$Temperature[ind_MCMC],
    #                           y=predMCMC$mean_pdf[ind_MCMC],
    #                           curve=mock_df$curve[3]), lwd=1)+
    scale_color_manual(values=c("red", "darkgrey", "dodgerblue3"))+
    scale_linetype_manual(values=c(1, 1, 6))+
    scale_alpha_manual(values=c(1, 0.2, 1))+
    xlab("Temperature value [°C]")+
    ylab("Temperature distribution\n(marginalized over time)")+
    ggtitle(paste0(stations$Station[i], " (", 
                   stations$Station.height.m..a..sea.level[i],
                   "m)")) + 
    theme(plot.title=element_text(size=10, hjust = 0.5),
          legend.position = "bottom",
          legend.title=element_blank())
  Lin[[i]][["data"]]
}

```


####Not the priority
```{r}

library(readxl)
library(raster)
library(rgdal)
rel <- raster("../datasets/relief/DTM Switzerland, 50m, by Sonny/DTM Switzerland 50m.tif",
              crs="+proj=utm +zone=32 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs +type=crs")
# ,
# crs="+proj=somerc +lat_0=46.95240555555556 +lon_0=7.439583333333333 +k_0=1 +x_0=600000 +y_0=200000 +ellps=bessel +towgs84=674.374,15.056,405.346,0,0,0,0 +units=m +no_defs")
crs(rel)
rel <- projectRaster(rel, crs="+proj=longlat +datum=WGS84")
rel_spdf <- as(rel, "SpatialPixelsDataFrame")
rel <- as.data.frame(rel_spdf)


summary(rel)
colnames(rel) <- c("h", "long", "lat")
disc_long <- 101
disc_lat <- 101
rel2 <- rel
rel2$long <- round(rel2$long*(disc_long-1))/(disc_long-1)
rel2$lat <- round(rel2$lat*(disc_lat-1))/(disc_lat-1)
rel2 <- rel2 %>%
  group_by(long, lat) %>%
  summarise(h=median(h)) %>%
  data.frame()


world_map <- map_data("world", region="Switzerland")
rel2$long <- round(rel2$long*(disc_long-1))/(disc_long-1)
rel2$lat <- round(rel2$lat*(disc_lat-1))/(disc_lat-1)
# Plot beginning
switzerland <- ggplot() + 
  geom_raster(rel2, mapping=aes(x=long, y=lat, fill=h*0), fill="white") +
  geom_raster(rel2, mapping=aes(x=long, y=lat, fill=h), alpha=0.5) +
  theme_void()+
  theme(legend.position="bottom", 
        legend.box = "horizontal") +
  scale_fill_viridis(option = "turbo", direction = +1, 
                     name="Elevation [m]",
                     guide = guide_colorbar(
                       direction = "horizontal",
                       barheight = unit(2, units = "mm"),
                       barwidth = unit(50, units = "mm"),
                       draw.ulim = F,
                       title.position = 'top',
                       # some shifting around
                       title.hjust = 0.5,
                       label.hjust = 0.5
                     ))+ 
  xlab("Longitude") + ylab("Latitude") 
switzerland

Lin <- list()
samples$station <- X$Station
for(i in seq(nrow(stations))){
  Lin[[i]]<-list()
  Lin[[i]][["histogram"]] <- ggplot(X[X$Station==stations$Station[i], ])+
    theme_bw()+
    geom_histogram(mapping=aes(x=tre200d0,
                               y=..density..),
                   col="grey70", fill="grey95", size=0.5, 
                   breaks=seq(range_temp[1], range_temp[2], 2))+
    coord_cartesian(xlim=range_temp, ylim=c(0, 0.07))+
    xlab("Temperature value [°C]")+
    ylab("Temperature distribution\n(marginalized over time)")+
    ggtitle(paste0(stations$Station[i], " (", 
                   stations$Station.height.m..a..sea.level[i],
                   "m)")) + 
    theme(plot.title=element_text(size=10, hjust = 0.5))
  ind_MAP <- df_MAP$Station==stations$Station[i]
  ind_MCMC <- df_MCMC$Station==stations$Station[i]
  ind_MCMC2 <- df_MCMC_rest$Station==stations$Station[i] & df_MCMC_rest$name %in% seq(1, 100, 5)
  Lin[[i]][["data"]]<- ggplot(mock_df, mapping=aes(x=x, y=y, lty=curve, col=curve, alpha=curve))+
    geom_line()+
    theme_bw()+
    geom_histogram(data=X[X$Station==stations$Station[i], ],
                   inherit.aes=FALSE,
                   mapping=aes(x=tre200d0,
                               y=..density..), col="midnightblue",  fill="lightsteelblue", 
                   alpha=0.1,
                   breaks=seq(range_temp[1], range_temp[2], 2))+
    geom_line(data=data.frame(x=df_MCMC_rest$t[ind_MCMC2],
                              y=df_MCMC_rest$value[ind_MCMC2],
                              id=df_MCMC_rest$name[ind_MCMC2], 
                              curve=mock_df$curve[2]), mapping=aes(group=id), alpha=0.5)+
    geom_line(data=data.frame(x=df_MAP$t[ind_MAP]*diff(range_temp)+range_temp[1],
                              y=df_MAP$pdf[ind_MAP]/diff(range_temp),
                              curve=mock_df$curve[1]), lwd=1)+
    geom_line(data=data.frame(x=df_MCMC$t[ind_MCMC]*diff(range_temp)+range_temp[1],
                              y=df_MCMC$mean_pdf[ind_MCMC]/diff(range_temp),
                              curve=mock_df$curve[3]), lwd=1)+
    scale_color_manual(values=c("red", "darkgrey", "dodgerblue3"))+
    scale_linetype_manual(values=c(1, 1, 6))+
    scale_alpha_manual(values=c(1, 0.2, 1))+
    coord_cartesian(xlim=range_temp, ylim=c(0, 0.07))+
    xlab("Temperature value [°C]")+
    ylab("Temperature distribution\n(marginalized over time)")+
    ggtitle(paste0(stations$Station[i], " (", 
                   stations$Station.height.m..a..sea.level[i],
                   "m)")) + 
    theme(plot.title=element_text(size=10, hjust = 0.5),
          legend.position = "bottom",
          legend.title=element_blank())
}

ind_first_image <- c(3, 24, 13)
ind_stations <- c(3, 24, 13, 15, 27)
ind_in_be <- c(4, 12, 18)
plot_map <-switzerland+
  # theme_classic()+
  geom_point(data=stations[ind_first_image, ], mapping = aes(x=Longitude, y=Latitude)) +
  geom_label_repel(data=stations[ind_first_image, ],
                   aes(x = Longitude, y = Latitude, label=Station),
                   size=3, alpha=0.9, 
                   point.padding = 0., 
                   nudge_x = .25,
                   nudge_y = .25,
                   segment.curvature = -1e-20)+
  ggtitle("Stations location.") + 
  theme(plot.title=element_text(size=10, hjust = 0.5))
plot_map2 <-switzerland+
  # theme_classic()+
  geom_point(data=stations[ind_in_be, ], mapping = aes(x=Longitude, y=Latitude)) +
  geom_label_repel(data=stations[ind_in_be, ],
                   aes(x = Longitude, y = Latitude, label=Station),
                   size=3, alpha=0.9, 
                   point.padding = 0., 
                   nudge_x = .25,
                   nudge_y = .25,
                   segment.curvature = -1e-20)+
  ggtitle("Stations location.") + 
  theme(plot.title=element_text(size=10, hjust = 0.5))
plot_map3 <-switzerland+
  # theme_classic()+
  geom_point(data=stations[ind_stations, ], mapping = aes(x=Longitude, y=Latitude)) +
  geom_label_repel(data=stations[ind_stations, ],
                   aes(x = Longitude, y = Latitude, label=Station),
                   size=3, alpha=0.9, 
                   point.padding = 0., 
                   nudge_x = .25,
                   nudge_y = .25,
                   segment.curvature = -1e-20)+
  ggtitle("Stations location.") + 
  theme(plot.title=element_text(size=10, hjust = 0.5))

plot_grid1 <- grid.arrange(plot_map, 
                           Lin[[3]][["histogram"]], 
                           Lin[[13]][["histogram"]], 
                           Lin[[24]][["histogram"]],
                           ncol=2, nrow = 2)
ggsave(plot_grid1, file="./Figures/grid_with_data_noSLGP2.png", 
       width=8, height=2/3*8, scale=1)
ggsave(plot_grid1, file="./Figures/grid_with_data_noSLGP2.pdf", 
       width=8, height=2/3*8, scale=1)

legend1 <- get_legend(Lin[[1]][["data"]]+
                        theme(legend.title = element_text())+
                        labs(lty="Curve represented",
                             col="Curve represented",
                             alpha="Curve represented"))
legend2 <- get_legend(Lin[[1]][["data"]]+
                        theme(legend.position = "left",
                              legend.direction = "vertical",
                              legend.title = element_text())+
                        labs(lty="Curve represented",
                             col="Curve represented",
                             alpha="Curve represented"))
plot_grid2 <- grid.arrange(plot_map2, 
                           Lin[[4]][["data"]]+ 
                             theme(legend.position="none"), 
                           Lin[[12]][["data"]]+ 
                             theme(legend.position="none"), 
                           Lin[[18]][["data"]]+ 
                             theme(legend.position="none"),
                           legend2,
                           ncol=3, nrow = 2, 
                           widths = c(3, 3, 1.8), heights = c(3, 3),
                           layout_matrix = rbind(c(1, 2, 5),
                                                 c(3, 4, 5)))
ggsave(plot_grid2, file="./Figures/grid_without_data2.png", 
       width=9.5, height=5.5, scale=1/1.15)
ggsave(plot_grid2, file="./Figures/grid_without_data2.pdf", 
       width=9.5, height=5.5, scale=1/1.15)
plot_grid2 <- grid.arrange(plot_map2, 
                           Lin[[4]][["data"]]+ 
                             theme(legend.position="none"), 
                           Lin[[12]][["data"]]+ 
                             theme(legend.position="none"), 
                           Lin[[18]][["data"]]+ 
                             theme(legend.position="none"),
                           legend1,
                           ncol=3, nrow = 3, 
                           widths = c(3, 3, 3), heights = c(3, 3, 0.8),
                           layout_matrix = rbind(c(NA, 1, NA),
                                                 c(2, 3, 4),
                                                 c(5, 5, 5)))
ggsave(plot_grid2, file="./Figures/grid_without_data2_2.png", 
       width=9.5, height=5.5, scale=1/1.15)
ggsave(plot_grid2, file="./Figures/grid_without_data2_2.pdf", 
       width=9.5, height=5.5, scale=1/1.15)
plot_grid3 <- grid.arrange(plot_map3, 
                           Lin[[3]][["data"]]+ 
                             theme(legend.position="none"), 
                           Lin[[27]][["data"]]+ 
                             theme(legend.position="none"), 
                           Lin[[13]][["data"]]+ 
                             theme(legend.position="none"),
                           Lin[[24]][["data"]]+ 
                             theme(legend.position="none"),
                           Lin[[15]][["data"]]+ 
                             theme(legend.position="none"),
                           legend1,
                           ncol=3, nrow = 3, 
                           widths = c(3, 3, 3), heights = c(3, 3, 0.8),
                           layout_matrix = rbind(c(2, 1, 3),
                                                 c(4, 5, 6),
                                                 c(7, 7, 7)))
ggsave(plot_grid3, file="./Figures/grid_stbernard22.png", 
       width=9.5, height=5.5, scale=1/1.15)

ggsave(plot_grid3, file="./Figures/grid_stbernard22.pdf", 
       width=9.5, height=5.5, scale=1/1.15)


disc_long <- 101
disc_lat <- 101
df2 <- data.frame(rel2)
df2$lat <- (df2$lat - range_lat[1])/diff(range_lat)
df2$long <- (df2$long - range_long[1])/diff(range_long)
df2$h <- c((df2$h - range_height[1])/diff(range_height))
rownames(df2) <- NULL
summary(df2)
df2$long <- round(df2$long*(disc_long-1))/(disc_long-1)
df2$lat <- round(df2$lat*(disc_lat-1))/(disc_lat-1)
df2 <- df2 %>%
  group_by(long, lat) %>%
  summarise(h=median(h), .groups="keep") %>%
  data.frame()
colnames(df2) <- c("x2", "x1", "x3")
df2 <- df2[, paste0("x", seq(3))]

stations_discretized <- stations_rescaled
stations_discretized$x1 <- round(stations_discretized$x1*100)/100
stations_discretized$x2 <- round(stations_discretized$x2*100)/100
stations_discretized$x3 <- NULL
stations_discretized$inBE <- NULL

df_plot_meteo <- evaluate_SLGP_grid(epsilon=Fit$Posterior1, 
                                    Xx=df2, 
                                    name_index, 
                                    lengthscale=res_opt$lengthscale,
                                    par_basis_functions=par_basis_functions)

df_plot_meteo2 <- merge(df_plot_meteo, stations_discretized, by=c("x1", "x2"), all.x=TRUE)
df_plot_meteo2$subset2 <- abs(df_plot_meteo2$x1+1.125*df_plot_meteo2$x2-0.86)<=0.03
df_plot_meteo2$subset1 <- abs(df_plot_meteo2$x1+1.125*df_plot_meteo2$x2-0.86)<=0.005
plotmap <- switzerland +
  # geom_abline(slope=-1.125*diff(range_lat)/diff(range_long), 
  #             intercept = diff(range_lat)*
  #               (0.86+1.125*(range_long[1])/diff(range_long))+
  #               range_lat[1])+
  geom_segment(aes(x=0.175*diff(range_long)+range_long[1],
                   xend=0.68*diff(range_long)+range_long[1],
                   y=47.12,
                   yend=46.01), col="black", size=2)+
  geom_segment(aes(x=0.175*diff(range_long)+range_long[1],
                   xend=0.68*diff(range_long)+range_long[1],
                   y=47.12,
                   yend=46.01), col="grey", lty=1)
plotmap

df_plot_meteo2 <- subset(df_plot_meteo2, df_plot_meteo2$subset2)
# line y=-1.125 x+ 0.86
library(StereoMorph)
orth_vect <- orthogonalProjectionToLine(df_plot_meteo2[, c(1:2)], l1 = c(0, 0.86), 
                                        l2 = c(1, 0.86-1.125))
df_plot_meteo2$x1proj <- orth_vect[, 1]
df_plot_meteo2$x2proj <- orth_vect[, 2]
df_plot_meteo2$dproj <- sqrt((df_plot_meteo2$x1-df_plot_meteo2$x1proj)^2+
                               (df_plot_meteo2$x2-df_plot_meteo2$x2proj)^2)
df_plot_meteo2<- df_plot_meteo2%>%
  mutate(place_on_line = 1-(x1proj-min(x1proj))/diff(range(x1proj)))%>%
  group_by(dproj)

df_plot_meteo2_summary <- df_plot_meteo2 %>%
  dplyr::select(-x1proj, -x2proj, -Station)%>%
  rename(lat=x1,
         long=x2, 
         alt=x3,
         temp=t)%>%
  mutate(temp=temp*diff(range_temp)+range_temp[1],
         lat=lat*diff(range_lat)+range_lat[1],
         long=long*diff(range_long)+range_long[1],
         alt=alt*diff(range_height)+range_height[1])%>%
  pivot_longer(-c("lat", "long", "alt", "temp", "place_on_line", "dproj","subset1", "subset2"))%>%
  mutate(value=ifelse(substr(name, 1, 4)=="pdf_", value/diff(range_temp), value))%>%
  mutate(simu=substr(name, 5, 10),
         name=substr(name, 1, 3))%>%
  group_by(lat, long, alt, simu)%>%
  summarise(place_on_line=mean(place_on_line),
            subset1 = median(subset1),
            subset2=median(subset2),
            dproj=mean(dproj),
            mean = mean(temp*value*(name=="pdf"))*2,
            q20 = temp[which.min(1e10*(name=="pdf")+abs(value-0.2))],
            q30 = temp[which.min(1e10*(name=="pdf")+abs(value-0.3))],
            q10 = temp[which.min(1e10*(name=="pdf")+abs(value-0.1))],
            q90 = temp[which.min(1e10*(name=="pdf")+abs(value-0.9))],
            q40 = temp[which.min(1e10*(name=="pdf")+abs(value-0.4))],
            q60 = temp[which.min(1e10*(name=="pdf")+abs(value-0.6))],
            q80 = temp[which.min(1e10*(name=="pdf")+abs(value-0.8))],
            q50 = temp[which.min(1e10*(name=="pdf")+abs(value-0.5))],
            q70 = temp[which.min(1e10*(name=="pdf")+abs(value-0.7))], 
            .groups="keep")%>%
  ungroup()%>%
  data.frame()
stations_other <- subset(df_plot_meteo2,
                         !is.na(df_plot_meteo2$Station)&
                           df_plot_meteo2$t==0)
stations_other <- dplyr::select(stations_other, -starts_with("pdf"))
stations_other <- dplyr::select(stations_other, -starts_with("cdf"))
stations_other<- stations_other%>%
  rename(lat=x1,
         long=x2, 
         alt=x3,
         temp=t)%>%
  mutate(temp=temp*diff(range_temp)+range_temp[1],
         lat=lat*diff(range_lat)+range_lat[1],
         long=long*diff(range_long)+range_long[1],
         alt=alt*diff(range_height)+range_height[1])

plot1 <- 
  df_plot_meteo2_summary %>%
  filter(subset1==1)%>%
  dplyr::select(-mean)%>%
  pivot_longer(starts_with("q"))%>%
  mutate(name=paste0(substr(name, 2, 3), "%"))%>%
  rename(`Quantile level`=name)%>%
  group_by(lat, long, alt, place_on_line, `Quantile level`)%>%
  summarise(mean=mean(value),
            qL=quantile(value, 0.1),
            qH = quantile(value, 0.9))%>%
  ggplot(aes(x=place_on_line, y=alt))+
  geom_ribbon(mapping=aes(ymin=0, ymax=alt), alpha=0.2, col="black", lty=1)+
  geom_label_repel(data=stations_other, mapping=aes(label=Station))+
  theme_bw()+
  theme(legend.position="bottom", 
        legend.box = "horizontal")+
  ylab("Elevation above sea level [m]")+
  xlab("Position alongside the slice")
# geom_vline(data=data.frame(place_on_line=stations_other$place_on_line+
#                              c(-0.02, +0.01, +0.02, +0.01, 0, 0),
#                            alt=stations_other$alt),
#            mapping=aes(xintercept=place_on_line))
plot1

plot2 <- 
  df_plot_meteo2_summary %>%
  filter(subset1==1)%>%
  dplyr::select(-mean)%>%
  pivot_longer(starts_with("q"))%>%
  mutate(name=paste0(substr(name, 2, 3), "%"))%>%
  rename(`Quantile level`=name)%>%
  group_by(lat, long, alt, place_on_line, `Quantile level`)%>%
  summarise(mean=mean(value),
            qL=quantile(value, 0.1),
            qH = quantile(value, 0.9))%>%
  ggplot(aes(x=place_on_line, col=`Quantile level`, fill=`Quantile level`))+
  geom_line(mapping=aes(y=mean))+
  geom_ribbon(mapping=aes(ymin=qL, ymax=qH), alpha=0.2, lty=2)+
  theme_bw()+
  theme(legend.position="bottom", 
        legend.box = "horizontal")+
  ylab("Temperature value [°C]")+
  xlab("Position alongside the slice")+
  geom_vline(xintercept =stations_other$place_on_line+
               c(-0.02, +0.01, +0.02, +0.01, 0, 0), lty=2)+
  geom_label(data=stations_other, mapping=aes(label=Station, 
                                              y=c(-22, -17, -22,-12,-17,-22), x=place_on_line), inherit.aes = FALSE)
plot2 


plot_grid <- grid.arrange(plotmap+ theme(aspect.ratio=0.5), 
                          plot1, plot2,
                          ncol=2, nrow = 2, 
                          widths = c(3, 3), heights = c(3, 4),
                          layout_matrix = rbind(c(1, 1),
                                                c(2, 3)),
                          respect=FALSE)
ggsave(plot_grid, file="./Figures/slice_switzerland.png", 
       width=9.5, height=5.5, scale=1.1)
ggsave(plot_grid, file="./Figures/slice_switzerland.pdf", 
       width=9.5, height=5.5, scale=1.1)

subset <- df_plot_meteo2$x1
df_plot_meteo_summary <- df_plot_meteo %>%
  rename(lat=x1,
         long=x2, 
         alt=x3,
         temp=t)%>%
  mutate(temp=temp*diff(range_temp)+range_temp[1],
         lat=lat*diff(range_lat)+range_lat[1],
         long=long*diff(range_long)+range_long[1],
         alt=alt*diff(range_height)+range_height[1])%>%
  pivot_longer(-c("lat", "long", "alt", "temp"))%>%
  mutate(value=ifelse(substr(name, 1, 4)=="pdf_", value/diff(range_temp), value))%>%
  mutate(simu=substr(name, 5, 10),
         name=substr(name, 1, 3))%>%
  group_by(lat, long, alt, simu)%>%
  summarise(mean = mean(temp*value*(name=="pdf"))*2,
            q50 = temp[which.min(1e10*(name=="pdf")+abs(value-0.5))],
            q10 = temp[which.min(1e10*(name=="pdf")+abs(value-0.1))],
            q90 = temp[which.min(1e10*(name=="pdf")+abs(value-0.9))],
            q25 = temp[which.min(1e10*(name=="pdf")+abs(value-0.25))],
            q75 = temp[which.min(1e10*(name=="pdf")+abs(value-0.75))],
            inv25 = value[which.min(abs(temp-25)+1e10*(name=="pdf"))],
            inv20 = value[which.min(abs(temp-20)+1e10*(name=="pdf"))],
            inv15 = value[which.min(abs(temp-15)+1e10*(name=="pdf"))],
            inv10 = value[which.min(abs(temp-10)+1e10*(name=="pdf"))],
            invminus10 = value[which.min(abs(temp+10)+1e10*(name=="pdf"))],
            inv5 = value[which.min(abs(temp-5)+1e10*(name=="pdf"))],
            invminus5 = value[which.min(abs(temp+5)+1e10*(name=="pdf"))],
            inv = value[which.min(abs(temp+0)+1e10*(name=="pdf"))], .groups="keep")%>%
  ungroup()%>%
  data.frame()

df_plot_meteo_summary <- df_plot_meteo_summary %>%
  ungroup()%>%
  pivot_longer(-c("lat", "long", "alt", "simu"))%>%
  group_by(lat, long, alt, name)%>%
  summarise(expectation=mean(value),
            sd=sd(value), .groups="keep")%>%
  ungroup()%>%
  rename(quantity=name)%>%
  pivot_longer(-c("lat", "long", "alt", "quantity"))%>%
  
  pivot_wider(names_from = quantity, values_from = value)%>%
  ungroup()%>%
  data.frame()
ind_exp <- df_plot_meteo_summary$name=="expectation"
plot1 <- ggplot(df_plot_meteo_summary[ind_exp, ],
                aes(x=long, y=lat, fill=q50))+
  geom_raster()+
  theme_void()+
  theme(legend.position="bottom", 
        legend.box = "horizontal") +
  scale_fill_viridis(option = "magma", direction = -1, 
                     name="Expected value [°C]",
                     guide = guide_colorbar(
                       direction = "horizontal",
                       barheight = unit(2, units = "mm"),
                       barwidth = unit(50, units = "mm"),
                       draw.ulim = F,
                       title.position = 'top',
                       # some shifting around
                       title.hjust = 0.5,
                       label.hjust = 0.5
                     ))+ 
  xlab("Longitude") + ylab("Latitude") 
plot2 <- ggplot(df_plot_meteo_summary[!ind_exp, ],
                aes(x=long, y=lat, fill=q50))+
  geom_raster()+
  theme_void()+
  theme(legend.position="bottom", 
        legend.box = "horizontal") +
  scale_fill_viridis(option = "magma", direction = -1, 
                     name="Standard deviation [°C]",
                     guide = guide_colorbar(
                       direction = "horizontal",
                       barheight = unit(2, units = "mm"),
                       barwidth = unit(50, units = "mm"),
                       draw.ulim = F,
                       title.position = 'top',
                       # some shifting around
                       title.hjust = 0.5,
                       label.hjust = 0.5
                     ))+ 
  xlab("Longitude") + ylab("Latitude") 
plot_grid <- grid.arrange(plot1, plot2, ncol=2)
ggsave(plot_grid, file="./Figures/grid_about_q50.png", 
       width=9, height=3.5, scale=1)
ggsave(plot_grid, file="./Figures/grid_about_q50.pdf", 
       width=9, height=3.5, scale=1)

plot1 <- ggplot(df_plot_meteo_summary[ind_exp, ],
                aes(x=long, y=lat, fill=mean))+
  geom_raster()+
  theme_void()+
  theme(legend.position="bottom", 
        legend.box = "horizontal") +
  scale_fill_viridis(option = "magma", direction = -1, 
                     name="Expected value [°C]",
                     guide = guide_colorbar(
                       direction = "horizontal",
                       barheight = unit(2, units = "mm"),
                       barwidth = unit(50, units = "mm"),
                       draw.ulim = F,
                       title.position = 'top',
                       # some shifting around
                       title.hjust = 0.5,
                       label.hjust = 0.5
                     ))+ 
  xlab("Longitude") + ylab("Latitude") 
plot2 <- ggplot(df_plot_meteo_summary[!ind_exp, ],
                aes(x=long, y=lat, fill=mean))+
  geom_raster()+
  theme_void()+
  theme(legend.position="bottom", 
        legend.box = "horizontal") +
  scale_fill_viridis(option = "magma", direction = -1, 
                     name="Standard deviation [°C]",
                     guide = guide_colorbar(
                       direction = "horizontal",
                       barheight = unit(2, units = "mm"),
                       barwidth = unit(50, units = "mm"),
                       draw.ulim = F,
                       title.position = 'top',
                       # some shifting around
                       title.hjust = 0.5,
                       label.hjust = 0.5
                     ))+ 
  xlab("Longitude") + ylab("Latitude") 
plot_grid <- grid.arrange(plot1, plot2, ncol=2)
ggsave(plot_grid, file="./Figures/grid_about_mean.png", 
       width=9, height=3.5, scale=1)
ggsave(plot_grid, file="./Figures/grid_about_mean.pdf", 
       width=9, height=3.5, scale=1)
```

