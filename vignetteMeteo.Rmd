---
title: "An application: SLGP-based prediction of temperature distributions at meteorological stations in Switzerland."
author: "Athénaïs Gautier"
date: "Last revised - October 2024"
output:
  html_document:
  #bookdown::pdf_document2 :
  #  keep_tex: false
  #  toc: false
  #  number_sections: true
    citation_package: natbib
bibliography: references.bib
header-includes:
 \usepackage{float}
 \usepackage{tikz}
 \usepackage{xcolor}
 \usepackage{amsmath, amsfonts, amsthm}
 \floatplacement{figure}{H}
 \usepackage{fvextra}
 \DefineVerbatimEnvironment{Highlighting}{Verbatim}{breaklines,commandchars=\\\{\}}

---

\newcommand{\xX}{\mathbf{x}}
\newcommand{\xI}{\mathcal{T}}
\newcommand{\xR}{\mathbb{R}}
\newcommand{\dimI}{d_\xI}
\newcommand{\dimD}{d_D}
\newcommand{\dxx}{d_{\xX, \xX'}}
\newcommand{\kincrement}{k_{\text{inc}}}
\newcommand{\mincrement}{m_{\text{inc}}}
\newcommand{\xM}{M(\xX, \xX')}
\newcommand{\diam}{D_{\xX, \xX'}(\xI)}
\newcommand{\xY}{\Vert \xX - \xX' \Vert^{\alpha_1 /2}}
\newcommand{\sigFieldM}{\mathcal{B}(\xI)}

\newcommand{\proc}[3]{
\ifstrempty{#3}%
{%
\ifstrempty{#2}%
{%
#1
}{%
#1_{#2}
}%
}{%
(#1_{#2})_{#3}
}%
}

```{r loadlibs, setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(ggplot2)
library(viridis)
```

## Introduction

In this vignette, we apply the Spatial Logistic Gaussian Process (SLGP) model to estimate temperature distributions at meteorological stations across Switzerland. This example illustrates SLGP's capacity to model spatial temperature variations based on location-specific factors, such as latitude, longitude, and altitude, using real meteorological data made available by MeteoSwiss [@meteorology_climatological_2019].

## Data Loading and Visualization

We begin by loading and visualizing the dataset of daily average temperatures at 29 meteorological stations across Switzerland. This initial step provides insight into temperature variability across different regions and altitudes.

```{r dataset}
# Dataset
X <- read.csv("./data_meteo.txt", encoding = "latin1")
stations <- unique(X[, c(1, 8:13)])

world_map <- map_data("world", region="Switzerland") #Load a map
```

```{r topography, include=FALSE, warning=FALSE, message=FALSE, echo=FALSE}
load(file="topography.RData")
switzerland <- ggplot() + 
  geom_raster(topography, mapping=aes(x=long, y=lat, fill=h*0), fill="white") +
  geom_raster(topography, mapping=aes(x=long, y=lat, fill=h), alpha=0.5) +
  theme_void()+
  theme(legend.position="bottom", 
        legend.box = "horizontal") +
  scale_fill_viridis(option = "turbo", direction = +1, 
                     name="Elevation [m]",
                     guide = guide_colorbar(
                       direction = "horizontal",
                       barheight = unit(2, units = "mm"),
                       barwidth = unit(50, units = "mm"),
                       draw.ulim = F,
                       title.position = 'top',
                       # some shifting around
                       title.hjust = 0.5,
                       label.hjust = 0.5
                     ))+ 
  xlab("Longitude") + ylab("Latitude") 
```

```{r mapplot1, include=FALSE, fig.cap="Meteorological stations where measurements are available", fig.fullwidth=TRUE, fig.height=8, fig.width=8, fig.align='center',fig.pos="H", warning=FALSE, message=FALSE, echo=FALSE}
library(ggrepel)
plot_map <-switzerland+
  # theme_classic()+
  geom_point(data=stations, mapping = aes(x=Longitude, y=Latitude)) +
  geom_label_repel(data=stations,
                   aes(x = Longitude, y = Latitude, 
                       label=Station),
                   # label=paste0(Station, "(", Station.height.m..a..sea.level, "m)")),
                   size=3, alpha=0.9, 
                   point.padding = 0., 
                   nudge_x = .25,
                   nudge_y = .25,
                   segment.curvature = -1e-20)+
  theme(plot.title=element_text(size=10, hjust = 0.5))
plot_map
# ggsave("./figures/map_switzerland.png", width=8, height=4.5)
# ggsave("./figures/map_switzerland.pdf", width=8, height=4.5)
```

To ensure a smooth modeling process, we prepare the dataset by renaming variables for clarity and storing their respective value ranges. This step facilitates easier handling of variables in subsequent modeling steps.

```{r startinit}
#Ready to normalise
range_temp <- c(-30, 40)
range_lat <- range(topography$lat)
range_long <- range(topography$long)
range_height <- c(0, 4810)

#Extract the relevant columns
samples <- X[, c("tre200d0", "Latitude", "Longitude", "Station.height.m..a..sea.level")]
colnames(samples) <- c("Temperature", "Latitude", "Longitude", "Altitude")
summary(samples)
```

We will use data from stations outside the canton of Bern for training the SLGP model, leaving the remaining stations as a test set to assess generalization. The model will predict temperature distributions based on the latitude, longitude, and altitude of each station.

```{r plotdensities, fig.cap = "Empirical distributions of temperatures at the considered stations", fig.fullwidth=TRUE, fig.height=8, fig.width=10, fig.align='center',fig.pos="H", warning=FALSE, message=FALSE, echo=FALSE}
plotDensities <- merge(samples, stations[, c(2, 4, 5, 7)]) %>%
  mutate(inCantonBE = Canton=="BE")%>%
  mutate(inCantonBE2 = ifelse(inCantonBE, 
                              "In the canton of Bern (test set)", 
                              "Out of the canton of Bern (train set)"))%>%
  ggplot()+    
  geom_line(data=data.frame(x=c(1:2-1000), y=c(0, 0)),
            mapping=aes(x=x, y=y, col="Pointwise KDE"))+
  geom_histogram(mapping=aes(x=Temperature, y=after_stat(density), 
                             fill=inCantonBE2),  col="white", lwd=0.1,
                 breaks = seq(-30, 40, 2.0), alpha=0.2, lwd=0.01)+
  geom_density(mapping=aes(x=Temperature), col="black")+
  scale_fill_manual(values=c("In the canton of Bern (test set)"="cornflowerblue", 
                             "Out of the canton of Bern (train set)"="darkgrey"))+
  facet_wrap(paste0(Station, " (", Altitude, "m)")~.)+
  theme_bw() +
  theme(legend.position = "bottom")+
  labs(title = "Temperature distribution by station.",
       subtitle = "Empirical distributions in the dataset",
       x = "Temperature (°C)",
       y = "Density",
       fill = "Canton of the station",
       col="Curve represented")+
  coord_cartesian(xlim=range_temp, ylim=c(0, 0.07))+
  scale_color_manual(values=c("SLGP-MAP"="red",
                              "Pointwise KDE"="black"))
plotDensities
```

## Initial SLGP Estimation with Arbitrary Hyperparameters


To understand the model's baseline behavior, we perform an initial SLGP estimation using arbitrary hyperparameters. This first run provides insight into the model’s ability to capture the temperature distribution’s overall structure.

```{r SLGPtoobig, fig.cap = "A SLGP estimation with poorly chosen lengthscale (too big)", fig.fullwidth=TRUE, fig.height=8, fig.width=10, fig.align='center',fig.pos="H", warning=FALSE, message=FALSE, echo=FALSE}
library(SLGP)
samples <- merge(samples, stations[, c(2, 4, 5, 7)]) %>%
  mutate(inCantonBE = Canton=="BE")

model1 <- slgp(Temperature~.,
               data=samples[!samples$inCantonBE, 1:4],
               method="MAP",
               basisFunctionsUsed = "RFF",
               interpolateBasisFun="nothing",
               hyperparams = list(lengthscale=rep(0.3, 4), 
                                  sigma2=1),
               predictorsUpper= c(range_lat[2], 
                                  range_long[2], 
                                  range_height[2]),
               predictorsLower= c(range_lat[1], 
                                  range_long[1], 
                                  range_height[1]),
               responseRange= range_temp,
               sigmaEstimationMethod = "heuristic",
               seed=1,
               opts_BasisFun = list(nFreq=250,
                                    MatParam=5/2))
dfGrid <- expand.grid(seq(-30, 40,, 201), seq(nrow(stations)))
dfGrid <- cbind(dfGrid[, 1], stations[dfGrid[, 2], c(4, 5, 3)])
colnames(dfGrid) <- c("Temperature", "Latitude", "Longitude", "Altitude")
pred <- predictSLGP_newNode(SLGPmodel=model1,
                            newNodes = dfGrid)
pred <- merge(pred, stations[, c(2, 4, 5, 7)]) %>%
  mutate(inCantonBE = Canton=="BE")

plotDensities + 
  geom_line(data = pred, mapping=aes(x=Temperature, 
                                     y=pdf_1,
                                     col="SLGP-MAP"))+
  labs(title = "Temperature distribution by station.",
       subtitle = "Empirical distributions in the dataset and SLGP MAP estimator with poorly chosen hyperparameters (large value).",
       col="Curve represented") 
```

The initial results show that while the model captures the general support of the temperature distribution, it fails to capture finer details, such as multi-modalities in certain distributions. This limitation likely arises from using a large length scale, which oversmooths small-scale variations.

To investigate further, we run the SLGP with a much smaller length scale. This adjustment helps reveal the model’s response to hyperparameter tuning and allows us to compare results across different spatial aggregation levels.


```{r SLGPtoosmall, fig.cap = "A SLGP estimation with poorly chosen lengthscale (too small)", fig.fullwidth=TRUE, fig.height=8, fig.width=10, fig.align='center',fig.pos="H", warning=FALSE, message=FALSE, echo=FALSE}
model2 <- slgp(Temperature~.,
               data=samples[!samples$inCantonBE, 1:4],
               method="MAP",
               basisFunctionsUsed = "RFF",
               interpolateBasisFun="nothing",
               hyperparams = list(lengthscale=rep(0.05, 4), 
                                  sigma2=1),
               predictorsUpper= c(range_lat[2], 
                                  range_long[2], 
                                  range_height[2]),
               predictorsLower= c(range_lat[1], 
                                  range_long[1], 
                                  range_height[1]),
               responseRange= range_temp,
               sigmaEstimationMethod = "heuristic",
               seed=1,
               opts_BasisFun = list(nFreq=250,
                                    MatParam=5/2))
pred <- predictSLGP_newNode(SLGPmodel=model2,
                            newNodes = dfGrid)
pred <- merge(pred, stations[, c(2, 4, 5, 7)]) %>%
  mutate(inCantonBE = Canton=="BE")

plotDensities + 
  geom_line(data = pred, mapping=aes(x=Temperature, 
                                     y=pdf_1,
                                     col="SLGP-MAP"))+
  scale_color_manual(values=c("SLGP-MAP"="red",
                              "Pointwise KDE"="black"))+
  labs(title = "Temperature distribution by station.",
       subtitle = "Empirical distributions in the dataset and SLGP MAP estimator with poorly chosen hyperparameters (small value).",
       col="Curve represented") 
```

This time, while the model provides accurate temperature estimates at stations within the training set, it generalizes poorly to test stations. Using too small a length scale restricts the model’s spatial aggregation, limiting the reach of spatial information to a very local scope.

## Selecting an Optimal Length Scale with Grid Search

To balance between overly small and overly large length scales, we propose selecting an appropriate length-scale hyperparameter via a grid search, aiming to find a balanced length scale that performs well across different spatial contexts. This grid search involves computing the (unnormalized) posterior for various candidate length scales, and selecting the hyperparameter value that maximizes it. This approach seeks a compromise between the previously observed limitations: length scales that are too small, which limit spatial aggregation, and those that are too large, which oversmooth local variations.

In Switzerland, we expect altitude to be the most significant factor influencing temperature variation, often more so than latitude and longitude. Consequently, we opted to share a single length scale for latitude and longitude, thereby slightly reducing the computational cost of estimation and simplifying the visualization of the results. For clarity, the code presented here is structured as a single loop; however, in practical applications, we parallelized the computations to improve efficiency.

```{r CV, eval=FALSE}
dinvgamma <- function(x, alpha=3, beta=0.3) {
  ifelse(x<=0, 0, (beta^alpha / gamma(alpha)) * x^(-alpha - 1) * exp(-beta / x))
}

df_res <- data.frame(lt=NA, lx1=NA, lx2=NA, lx3=NA, value=NA)[c(0), ]
for(lx1 in seq(0.05, 0.5, 0.05)){
  lx2 <- lx1
  for(lx3 in seq(0.05, 0.5, 0.05)){
    for(lt in  seq(0.05, 0.3, 0.025)){
      starting_lengthscale <- c(lt, lx1, lx2, lx3)
      names(starting_lengthscale) <- paste0("Lengthscale ", c("t", name_index))
      print(starting_lengthscale)
      
      mod <- slgp(Temperature~.,
                  data=samplesTrain,
                  method="MAP",
                  basisFunctionsUsed = "RFF",
                  interpolateBasisFun="nothing",
                  hyperparams = list(lengthscale=starting_lengthscale,
                                     sigma2=1),
                  predictorsUpper= c(range_lat[2],
                                     range_long[2],
                                     range_height[2]),
                  predictorsLower= c(range_lat[1],
                                     range_long[1],
                                     range_height[1]),
                  responseRange= range_temp,
                  sigmaEstimationMethod = "heuristic",
                  seed=1,
                  opts_BasisFun = list(nFreq=250,
                                       MatParam=5/2))
      pred <- predictSLGP_newNode(SLGPmodel=mod,
                                  newNodes = samplesTest)
      logprior <- log(dinvgamma(lx1))+log(dinvgamma(lx2))+log(dinvgamma(lx3))+log(dinvgamma(lt))
      df_res <- rbind(dfres, c(starting_lengthscale, -sum(log(pred$pdf_1))-logprior))
    }
  }
}
save(df_res, file="resultsMeteo.RData" )
```

We can now display the resulting optimisation profile. 

```{r include=FALSE, fig.cap = "Optimisation profile for the SLGP's lengthscales on the meteorological application", fig.fullwidth=TRUE, fig.height=8, fig.width=10, fig.align='center',fig.pos="H", warning=FALSE, message=FALSE, echo=FALSE}
library(scales)
load(file="resultsMeteo.RData" )
best_value <- range(df_res$value)

# Only display a subplot, for compacity purposes
ind <- df_res$`Lengthscale t` <= 0.3 &
  df_res$`Lengthscale x3`<= 0.25 &
  df_res$`Lengthscale x1`<= 0.5 &
  df_res$`Lengthscale x1`>= 0.25


df_res <- df_res[ind, ]
df_res <- df_res %>%
  mutate(`Lengthscale t`=`Lengthscale t`*100)%>%
  mutate(`Lengthscale x1`=ifelse(`Lengthscale x1`==0.05,
                                 paste0("Latitude\nlongitude\n05% of range"),
                                 paste0("Latitude\nlongitude\n", `Lengthscale x1`*100, "% of range")))%>%
  mutate(`Lengthscale x3`=ifelse(`Lengthscale x3`==0.05,
                                 paste0("Altitude\n05% of range"),
                                 paste0("Altitude\n", `Lengthscale x3`*100, "% of range")))%>%
  group_by_at(paste0("Lengthscale x", seq(3)))%>%
  mutate(gives_min=any(value==best_value[1]))%>%
  mutate(to1percentmin=any(value<=0.99*best_value[1]))%>%
  ungroup()

list_lx <- seq(0.05, 0.5, 0.05)
list_lt <- seq(0.05, 0.3, 0.025)
df_res %>%
  ggplot(aes(x=`Lengthscale t`, y=value))+
  geom_line()+
  geom_rect(data = subset(df_res, to1percentmin&!gives_min&`Lengthscale t`==10), 
            fill = "cornflowerblue", col="blue", lty=2,
            alpha=0.1,
            xmin = 100*(list_lt[1]-diff(range(list_lt))*10.04), 
            xmax = 100*(list_lt[length(list_lt)]+diff(range(list_lt))*10.04),
            ymin = 1*(best_value[1]-diff(best_value)*10.03), 
            ymax = 1*(best_value[2]+diff(best_value)*10.03))+
  geom_rect(data = subset(df_res, gives_min), 
            fill = "green", alpha=0.01,
            colour = "forestgreen", lty=1,
            xmin = 100*(list_lt[1]-diff(range(list_lt))*10.04), 
            xmax = 100*(list_lt[length(list_lt)]+diff(range(list_lt))*10.04),
            ymin = 1*(best_value[1]-diff(best_value)*10.03), 
            ymax = 1*(best_value[2]+diff(best_value)*10.03))+
  facet_grid(`Lengthscale x3`~`Lengthscale x1`)+
  theme_bw()+
  geom_hline(yintercept=min(df_res$value), col="grey")+
  xlab("Lengthscale for Temperature (in % of range)")+
  ylab("Negative log-posterior")+ 
  scale_y_continuous(labels = scientific)
```

Using the optimal length scale hyperparameter identified in the grid search, we perform the final SLGP estimation. This provides the best compromise between local accuracy and generalization, as shown by improved prediction results at the test stations.

```{r SLGPgood, warning=FALSE, message=FALSE, eval=FALSE}
load(file="resultsMeteo.RData" )

lengthscale <- as.numeric(df_res[which.min(df_res$value), 1:4])
model3 <- slgp(Temperature~.,
               data=samples[!samples$inCantonBE, 1:4],
               method="MCMC",
               basisFunctionsUsed = "RFF",
               interpolateBasisFun="nothing",
               hyperparams = list(lengthscale=lengthscale, 
                                  sigma2=1),
               predictorsUpper= c(range_lat[2], 
                                  range_long[2], 
                                  range_height[2]),
               predictorsLower= c(range_lat[1], 
                                  range_long[1], 
                                  range_height[1]),
               responseRange= range_temp,
               sigmaEstimationMethod = "heuristic",
               seed=1,
               opts_BasisFun = list(nFreq=250,
                                    MatParam=5/2),
               opts = list(stan_chains=2, stan_iter=1000))
model3MAP <- slgp(Temperature~.,
                  data=samples[!samples$inCantonBE, 1:4],
                  method="MAP",
                  basisFunctionsUsed = "RFF",
                  interpolateBasisFun="nothing",
                  hyperparams = list(lengthscale=lengthscale, 
                                     sigma2=1),
                  predictorsUpper= c(range_lat[2], 
                                     range_long[2], 
                                     range_height[2]),
                  predictorsLower= c(range_lat[1], 
                                     range_long[1], 
                                     range_height[1]),
                  responseRange= range_temp,
                  sigmaEstimationMethod = "heuristic",
                  seed=1,
                  opts_BasisFun = list(nFreq=250,
                                       MatParam=5/2))

save(model3, model3MAP, file="ModelOptimizedLen.RData")

```

```{r SLGPgood2,, fig.cap = "A SLGP estimation with optimally chosen lengthscale (grid-search)", fig.fullwidth=TRUE, fig.height=8, fig.width=10, fig.align='center',fig.pos="H", warning=FALSE, message=FALSE, echo=FALSE}
load(file="ModelOptimizedLen.RData")

predMCMC <- predictSLGP_newNode(SLGPmodel=model3,
                                newNodes = dfGrid, nDiscret=201)
predMAP <- predictSLGP_newNode(SLGPmodel=model3MAP,
                               newNodes = dfGrid, nDiscret=201)
predMCMC$mean_pdf <- rowMeans(predMCMC[, -c(1:4)])

predMCMC <- merge(predMCMC, stations[, c(2, 4, 5, 7)]) %>%
  mutate(inCantonBE = Canton=="BE")
predMAP <- merge(predMAP, stations[, c(2, 4, 5, 7)]) %>%
  mutate(inCantonBE = Canton=="BE")
predMCMC2 <- predMCMC[, c(1:(4+100), 1005:1008)]%>%
  dplyr::select(Latitude | Longitude | Altitude | 
                  Temperature | starts_with("pdf") | Station)%>%
  pivot_longer(-c("Temperature", "Latitude", "Longitude", "Altitude", "Station"))%>%
  mutate(name=as.numeric(substr(name, 5, 11)))

plotDensities + 
  geom_line(data = predMAP, mapping=aes(x=Temperature, 
                                        y=pdf_1,
                                        col="SLGP-MAP"))+
  scale_color_manual(values=c("SLGP-MAP"="red",
                              "Pointwise KDE"="black"))+
  labs(title = "Temperature distribution by station.",
       subtitle = "Empirical distributions in the dataset and SLGP MAP estimator with optimised hyperparameters.",
       col="Curve represented") 
```
## Visualising results at some stations both in and out of the training set

```{r preparepanelplots, include=FALSE, warning=FALSE, message=FALSE}

mock_df <- data.frame(x=c(rep(-1000, 3), rep(-2000, 3)),
                      y=0, curve=rep(c("SLGP-MAP", "SLGP-MCMC draws", "SLGP-MCMC mean"), 2))
Lin <- list()


for(i in seq(nrow(stations))){
  Lin[[i]]<-list()
  Lin[[i]][["histogram"]] <-   samples%>%
    dplyr::filter(Station==stations$Station[i])%>%
    mutate(inCantonBE2 = ifelse(inCantonBE, 
                                "In the canton of Bern (test set)", 
                                "Out of the canton of Bern (train set)"))%>%
    ggplot()+  
    geom_line(data=data.frame(x=c(1:2-1000), y=c(0, 0)),
              mapping=aes(x=x, y=y, col="Pointwise KDE"))+
    geom_histogram(mapping=aes(x=Temperature, y=after_stat(density), 
                               fill=inCantonBE2),  col="white", lwd=0.2,
                   breaks = seq(-30, 40, 2.0), alpha=0.2)+  
    geom_histogram(data=data.frame(Temperature=seq(2)-1000,
                                   inCantonBE2=c("In the canton of Bern (test set)", 
                                                 "Out of the canton of Bern (train set)")),
                   mapping=aes(x=Temperature, y=after_stat(density),
                               fill=inCantonBE2, col="white"), 
                   breaks = seq(-30, 40, 2.5), alpha=0.2)+
    geom_density(mapping=aes(x=Temperature), col="black")+
    scale_fill_manual(values=c("In the canton of Bern (test set)"="cornflowerblue", 
                               "Out of the canton of Bern (train set)"="darkgrey"))+
    facet_wrap(paste0(Station, " (", Altitude, "m)")~.)+
    theme_bw() +
    theme(legend.position = "bottom")+
    labs(x= "Temperature value [°C]",
         y = "Probability density",
         fill = "Canton of the station",
         col="Curve represented")+
    coord_cartesian(xlim=range_temp, ylim=c(0, 0.07))
  
  
  ind_MAP <- predMAP$Station==stations$Station[i]
  ind_MCMC <- predMCMC$Station==stations$Station[i]
  ind_MCMC2 <- predMCMC2$Station==stations$Station[i] & predMCMC2$name %in% seq(1, 101, 5)
  Lin[[i]][["data"]] <- Lin[[i]][["histogram"]]+  
    geom_line(data=data.frame(x=c(1:2-1000), y=c(0, 0)),
              mapping=aes(x=x, y=y, lty="Pointwise KDE", 
                          col="Pointwise KDE", 
                          alpha="Pointwise KDE"))+
    geom_line(data=predMCMC2[ind_MCMC2, ],
              mapping=aes(x=Temperature, y=value, group=name, 
                          lty="SLGP-MCMC draws",
                          col="SLGP-MCMC draws",
                          alpha="SLGP-MCMC draws"),
              lwd=0.1)+
    geom_line(data=predMAP[ind_MAP, ],
              mapping=aes(x=Temperature, y=pdf_1, 
                          lty="SLGP-MAP",
                          col="SLGP-MAP",
                          alpha="SLGP-MAP"))+
    geom_line(data=predMCMC[ind_MCMC, ],
              mapping=aes(x=Temperature, y=mean_pdf, 
                          lty="SLGP-MCMC mean",
                          col="SLGP-MCMC mean",
                          alpha="SLGP-MCMC mean")) +
    scale_color_manual(values=c("SLGP-MAP"="red",
                                "SLGP-MCMC draws"="darkgrey", 
                                "SLGP-MCMC mean"="dodgerblue3",
                                "Pointwise KDE"="black"))+
    scale_linetype_manual(values=c("SLGP-MAP"=1, 
                                   "SLGP-MCMC draws"=1, 
                                   "SLGP-MCMC mean"=2,
                                   "Pointwise KDE"=1))+
    scale_alpha_manual(values=c("SLGP-MAP"=1, 
                                "SLGP-MCMC draws"=0.75, 
                                "SLGP-MCMC mean"=1,
                                "Pointwise KDE"=1))+
    labs(lty="Curve represented",
         col="Curve represented",
         alpha="Curve represented")
}

```


```{r figmix, fig.cap = "SLGP estimation for some stations both in the training set (=stations out of the Canton of Bern) and in the test set (=stations in the Canton of Bern)", fig.fullwidth=TRUE, fig.height=5.5, fig.width=9.5, fig.align='center',fig.pos="H", warning=FALSE, message=FALSE, echo=FALSE}
library(gridExtra)
library(cowplot)


pl1 <- Lin[[1]][["data"]]+
  theme(legend.position = "bottom",
        legend.direction = "horizontal",
        legend.title = element_text())+
  labs(lty=NULL,
       col=NULL,
       alpha=NULL,
       fill=NULL) +
  guides(fill="none")
# Convert the plot to a grob
grob_pl1 <- ggplotGrob(pl1)
# Extract the legend part of the grob
legend1 <- grob_pl1$grobs[[which(sapply(grob_pl1$grobs, function(x) x$name) == "guide-box")]]
pl2 <- Lin[[1]][["data"]]+
  theme(legend.position = "bottom",
        legend.direction = "horizontal",
        legend.title = element_text())+
  labs(lty=NULL,
       col=NULL,
       alpha=NULL,
       fill=NULL) +
  guides(lty="none",
         col="none",
         alpha="none")
# Convert the plot to a grob
grob_pl2 <- ggplotGrob(pl2)
# Extract the legend part of the grob
legend2 <- grob_pl2$grobs[[which(sapply(grob_pl2$grobs, function(x) x$name) == "guide-box")]]

ind_stations <- c(2, 4, 12, 18, 19)
plot_map <-switzerland+
  # theme_classic()+
  geom_point(data=stations[ind_stations, ], mapping = aes(x=Longitude, y=Latitude)) +
  geom_label_repel(data=stations[ind_stations, ],
                   aes(x = Longitude, y = Latitude, label=Station),
                   size=3, alpha=0.9, 
                   point.padding = 0., 
                   nudge_x = .25,
                   nudge_y = .25,
                   segment.curvature = -1e-20)+
  ggtitle("Stations location.") + 
  theme(plot.title=element_text(size=10, hjust = 0.5))

plot_grid <- grid.arrange(plot_map, 
                          Lin[[19]][["data"]]+ 
                            theme(legend.position="none"), 
                          Lin[[2]][["data"]]+ 
                            theme(legend.position="none"), 
                          Lin[[4]][["data"]]+ 
                            theme(legend.position="none"),
                          Lin[[18]][["data"]]+ 
                            theme(legend.position="none"),
                          Lin[[12]][["data"]]+ 
                            theme(legend.position="none"),
                          legend1,
                          legend2,
                          ncol=3, nrow = 4, 
                          widths = c(3, 3, 3), heights = c(3, 3, 0.4, 0.4),
                          layout_matrix = rbind(c(2, 1, 3),
                                                c(4, 5, 6),
                                                c(7, 7, 7),
                                                c(8, 8, 8)))
plot(plot_grid)
# ggsave(plot_grid, file="./Figures/grid_mixBE.png", 
#        width=9.5, height=5.5, scale=1/1.15)
# ggsave(plot_grid, file="./Figures/grid_mixBE.pdf", 
#        width=9.5, height=5.5, scale=1/1.15)

```

## Visualising results at some stations both out of the training set
```{r figout, fig.cap = "SLGP estimation for some other stations in the training set (=stations out of the Canton of Bern).", fig.fullwidth=TRUE, fig.height=5.5, fig.width=9.5, fig.align='center',fig.pos="H", warning=FALSE, message=FALSE, echo=FALSE}

ind_stations <- c(3, 28, 11, 13, 15)
plot_map <-switzerland+
  # theme_classic()+
  geom_point(data=stations[ind_stations, ], mapping = aes(x=Longitude, y=Latitude)) +
  geom_label_repel(data=stations[ind_stations, ],
                   aes(x = Longitude, y = Latitude, label=Station),
                   size=3, alpha=0.9, 
                   point.padding = 0.5, 
                   box.padding = 0.5,    
                   segment.curvature = -1e-20)+
  ggtitle("Stations location.") + 
  theme(plot.title=element_text(size=10, hjust = 0.5))

plot_grid <- grid.arrange(plot_map, 
                          Lin[[3]][["data"]]+ 
                            theme(legend.position="none"), 
                          Lin[[28]][["data"]]+ 
                            theme(legend.position="none"), 
                          Lin[[13]][["data"]]+ 
                            theme(legend.position="none"),
                          Lin[[11]][["data"]]+ 
                            theme(legend.position="none"),
                          Lin[[15]][["data"]]+ 
                            theme(legend.position="none"),
                          legend1,
                          legend2,
                          ncol=3, nrow = 4, 
                          widths = c(3, 3, 3), heights = c(3, 3, 0.4, 0.4),
                          layout_matrix = rbind(c(2, 1, 3),
                                                c(4, 5, 6),
                                                c(7, 7, 7),
                                                c(8, 8, 8)))
plot(plot_grid)
# ggsave(plot_grid, file="./Figures/grid_outofBE.png", 
#        width=9.5, height=5.5, scale=1/1.15)
# ggsave(plot_grid, file="./Figures/grid_outofBE.pdf", 
#        width=9.5, height=5.5, scale=1/1.15)

```

```{r figout2, fig.cap = "SLGP estimation for some other stations in the training set (=stations out of the Canton of Bern).", fig.fullwidth=TRUE, fig.height=5.5, fig.width=9.5, fig.align='center',fig.pos="H", warning=FALSE, message=FALSE, echo=FALSE}

ind_stations <- c(5, 29, 14, 25, 24)
plot_map <-switzerland+
  # theme_classic()+
  geom_point(data=stations[ind_stations, ], mapping = aes(x=Longitude, y=Latitude)) +
  geom_label_repel(data=stations[ind_stations, ],
                   aes(x = Longitude, y = Latitude, label=Station),
                   size=3, alpha=0.9, 
                   point.padding = 0.5, 
                   box.padding = 0.5,    
                   segment.curvature = -1e-20)+
  ggtitle("Stations location.") + 
  theme(plot.title=element_text(size=10, hjust = 0.5))

plot_grid <- grid.arrange(plot_map, 
                          Lin[[5]][["data"]]+ 
                            theme(legend.position="none"), 
                          Lin[[29]][["data"]]+ 
                            theme(legend.position="none"), 
                          Lin[[14]][["data"]]+ 
                            theme(legend.position="none"),
                          Lin[[25]][["data"]]+ 
                            theme(legend.position="none"),
                          Lin[[24]][["data"]]+ 
                            theme(legend.position="none"),
                          legend1,
                          legend2,
                          ncol=3, nrow = 4, 
                          widths = c(3, 3, 3), heights = c(3, 3, 0.4, 0.4),
                          layout_matrix = rbind(c(2, 1, 3),
                                                c(4, 5, 6),
                                                c(7, 7, 7),
                                                c(8, 8, 8)))
plot(plot_grid)
# ggsave(plot_grid, file="./Figures/grid_outofBE2.png", 
#        width=9.5, height=5.5, scale=1/1.15)
# ggsave(plot_grid, file="./Figures/grid_outofBE2.pdf", 
#        width=9.5, height=5.5, scale=1/1.15)

```

```{r figout3, fig.cap = "SLGP estimation for some other stations in the training set (=stations out of the Canton of Bern).", fig.fullwidth=TRUE, fig.height=5.5, fig.width=9.5, fig.align='center',fig.pos="H", warning=FALSE, message=FALSE, echo=FALSE}

ind_stations <- c(7, 23, 6, 10, 26)
plot_map <-switzerland+
  # theme_classic()+
  geom_point(data=stations[ind_stations, ], mapping = aes(x=Longitude, y=Latitude)) +
  geom_label_repel(data=stations[ind_stations, ],
                   aes(x = Longitude, y = Latitude, label=Station),
                   size=3, alpha=0.9, 
                   point.padding = 0.5, 
                   box.padding = 0.5,    
                   segment.curvature = -1e-20)+
  ggtitle("Stations location.") + 
  theme(plot.title=element_text(size=10, hjust = 0.5))

plot_grid <- grid.arrange(plot_map, 
                          Lin[[7]][["data"]]+ 
                            theme(legend.position="none"), 
                          Lin[[23]][["data"]]+ 
                            theme(legend.position="none"), 
                          Lin[[6]][["data"]]+ 
                            theme(legend.position="none"),
                          Lin[[10]][["data"]]+ 
                            theme(legend.position="none"),
                          Lin[[26]][["data"]]+ 
                            theme(legend.position="none"),
                          legend1,
                          legend2,
                          ncol=3, nrow = 4, 
                          widths = c(3, 3, 3), heights = c(3, 3, 0.4, 0.4),
                          layout_matrix = rbind(c(2, 1, 3),
                                                c(4, 5, 6),
                                                c(7, 7, 7),
                                                c(8, 8, 8)))
plot(plot_grid)
# ggsave(plot_grid, file="./Figures/grid_outofBE3.png", 
#        width=9.5, height=5.5, scale=1/1.15)
# ggsave(plot_grid, file="./Figures/grid_outofBE3.pdf", 
#        width=9.5, height=5.5, scale=1/1.15)

```

```{r figout4, fig.cap = "SLGP estimation for some other stations in the training set (=stations out of the Canton of Bern).", fig.fullwidth=TRUE, fig.height=5.5, fig.width=9.5, fig.align='center',fig.pos="H", warning=FALSE, message=FALSE, echo=FALSE}

ind_stations <- c(21, 9, 27, 20, 16)
plot_map <-switzerland+
  # theme_classic()+
  geom_point(data=stations[ind_stations, ], mapping = aes(x=Longitude, y=Latitude)) +
  geom_label_repel(data=stations[ind_stations, ],
                   aes(x = Longitude, y = Latitude, label=Station),
                   size=3, alpha=0.9, 
                   point.padding = 0.5, 
                   box.padding = 0.5,    
                   segment.curvature = -1e-20)+
  ggtitle("Stations location.") + 
  theme(plot.title=element_text(size=10, hjust = 0.5))

plot_grid <- grid.arrange(plot_map, 
                          Lin[[21]][["data"]]+ 
                            theme(legend.position="none"), 
                          Lin[[9]][["data"]]+ 
                            theme(legend.position="none"), 
                          Lin[[27]][["data"]]+ 
                            theme(legend.position="none"),
                          Lin[[20]][["data"]]+ 
                            theme(legend.position="none"),
                          Lin[[16]][["data"]]+ 
                            theme(legend.position="none"),
                          legend1,
                          legend2,
                          ncol=3, nrow = 4, 
                          widths = c(3, 3, 3), heights = c(3, 3, 0.4, 0.4),
                          layout_matrix = rbind(c(2, 1, 3),
                                                c(4, 5, 6),
                                                c(7, 7, 7),
                                                c(8, 8, 8)))
plot(plot_grid)
# ggsave(plot_grid, file="./Figures/grid_outofBE4.png", 
#        width=9.5, height=5.5, scale=1/1.15)
# ggsave(plot_grid, file="./Figures/grid_outofBE4.pdf", 
#        width=9.5, height=5.5, scale=1/1.15)

```


```{r figout5, fig.cap = "SLGP estimation for some other stations in the training set (=stations out of the Canton of Bern).", fig.fullwidth=TRUE, fig.height=5.5, fig.width=9.5, fig.align='center',fig.pos="H", warning=FALSE, message=FALSE, echo=FALSE}
library(grid)  # For nullGrob

ind_stations <- c(17, 1, 22, 8)
plot_map <-switzerland+
  # theme_classic()+
  geom_point(data=stations[ind_stations, ], mapping = aes(x=Longitude, y=Latitude)) +
  geom_label_repel(data=stations[ind_stations, ],
                   aes(x = Longitude, y = Latitude, label=Station),
                   size=3, alpha=0.9, 
                   point.padding = 0.5, 
                   box.padding = 0.5,    
                   segment.curvature = -1e-20)+
  ggtitle("Stations location.") + 
  theme(plot.title=element_text(size=10, hjust = 0.5))

plot_grid <- grid.arrange(plot_map, 
                          Lin[[17]][["data"]]+ 
                            theme(legend.position="none"), 
                          Lin[[22]][["data"]]+ 
                            theme(legend.position="none"), 
                          Lin[[1]][["data"]]+ 
                            theme(legend.position="none"),
                          nullGrob(),
                          Lin[[8]][["data"]]+ 
                            theme(legend.position="none"),
                          legend1,
                          legend2,
                          ncol=3, nrow = 4, 
                          widths = c(3, 3, 3), heights = c(3, 3, 0.4, 0.4),
                          layout_matrix = rbind(c(2, 1, 3),
                                                c(4, 5, 6),
                                                c(7, 7, 7),
                                                c(8, 8, 8)))
plot(plot_grid)
# ggsave(plot_grid, file="./Figures/grid_outofBE5.png", 
#        width=9.5, height=5.5, scale=1/1.15)
# ggsave(plot_grid, file="./Figures/grid_outofBE5.pdf", 
#        width=9.5, height=5.5, scale=1/1.15)

```
# Leveraging SLGP estimators for complex inference

Predict the MAP estimator over all of Switzerland.

```{r evalMAP, eval=FALSE}
df <- topography
colnames(df) <- c("Longitude", "Latitude", "Altitude")

disc_long <- 201
disc_lat <- 201
df <- df %>%
  mutate(Longitude=(Longitude-range_long[1])/diff(range_long),
         Latitude=(Latitude-range_lat[1])/diff(range_lat))%>%
  mutate(Longitude=round(Longitude*disc_long)/(disc_long),
         Latitude=round(Latitude*disc_lat)/(disc_lat))%>%
  group_by(Longitude, Latitude) %>%
  summarise(Altitude=median(Altitude), .groups="keep") %>%
  ungroup()%>%
  mutate(Longitude=Longitude*diff(range_long)+range_long[1],
         Latitude=Latitude*diff(range_lat)+range_lat[1]) %>%
  data.frame() 
df2 <- expand.grid(seq(range_temp[1], range_temp[2],, 141), seq(nrow(df)))
df2 <- cbind(df[df2$Var2, ], df2$Var1)
colnames(df2)[4] <- "Temperature"

dfSwissMAP<- data.frame()
rep <- 3*47
n <- nrow(df2)/rep
# Start time
start_time <- Sys.time()
for(i in seq(rep)){
  # Time at the start of each iteration
  iter_start_time <- Sys.time()
  cat(i, "\n")
  temp <- predictSLGP_newNode(SLGPmodel=model3MAP,
                              newNodes = df2[1:n  + (i-1)*n, ],
                              nDiscret=101)
  dfSwissMAP <- rbind(dfSwissMAP, temp)
  
  # Calculate elapsed time since the beginning in minutes
  elapsed_time <- as.numeric(difftime(Sys.time(), start_time, units = "mins"))
  iter_time <- as.numeric(difftime(Sys.time(), iter_start_time, units = "mins"))
  
  if(i%%3==0){
    cat("Saved just in case at ", i%/%3, "/47\n")
    save(dfSwissMAP, file="predictionInSwitzerlandMAP.RData")
  }
  # Print elapsed time and iteration time
  cat("Total elapsed time:", elapsed_time, 
      "mins\nTime for this iteration:", iter_time, "mins\n\n")
}
save(dfSwissMAP, file="predictionInSwitzerlandMAP.RData")
```

Predict the MCMC estimations over all of Switzerland.
```{r evalMCMC, eval=FALSE}

df <- topography
colnames(df) <- c("Longitude", "Latitude", "Altitude")

disc_long <- 101
disc_lat <- 101
df <- df %>%
  mutate(Longitude=(Longitude-range_long[1])/diff(range_long),
         Latitude=(Latitude-range_lat[1])/diff(range_lat))%>%
  mutate(Longitude=round(Longitude*disc_long)/(disc_long),
         Latitude=round(Latitude*disc_lat)/(disc_lat))%>%
  group_by(Longitude, Latitude) %>%
  summarise(Altitude=median(Altitude), .groups="keep") %>%
  ungroup()%>%
  mutate(Longitude=Longitude*diff(range_long)+range_long[1],
         Latitude=Latitude*diff(range_lat)+range_lat[1]) %>%
  data.frame() 
df2 <- expand.grid(seq(range_temp[1], range_temp[2],, 141), seq(nrow(df)))
df2 <- cbind(df[df2$Var2, ], df2$Var1)
colnames(df2)[4] <- "Temperature"

rep <- 47*3
n <- nrow(df2)/rep
# Start time
start_time <- Sys.time()
for(i in seq(131, rep)){
  # Time at the start of each iteration
  iter_start_time <- Sys.time()
  cat(i, "\n")
  temp <- predictSLGP_newNode(SLGPmodel=model3,
                              newNodes = df2[1:n  + (i-1)*n, ],
                              nDiscret=201)

  # Calculate elapsed time since the beginning in minutes
  elapsed_time <- as.numeric(difftime(Sys.time(), start_time, units = "mins"))
  iter_time <- as.numeric(difftime(Sys.time(), iter_start_time, units = "mins"))
  
  save(temp, file = paste0("./SavedData/predictionInSwitzerlandMCMC_", i, ".RData"))

  # Print elapsed time and iteration time
  cat("Total elapsed time:", elapsed_time, 
      "mins\nTime for this iteration:", iter_time, "mins\n\n")

}
gc()
```

... And now, let us use these!

## Temperature-Based Localisation in Switzerland: A Proof of Concept.

In this proof of concept, we demonstrate an "inverse problem" approach: given a temperature observation, we use the MAP (Maximum A Posteriori) estimator of the Spatial Logistic Gaussian Process (SLGP) model to identify likely regions in Switzerland where this temperature could have been observed. This allows us to infer potential locations based on specific temperature measurements.

```{r plotInvPb, fig.cap = "An inverse problem solved with SLGP modelling: temeprature based localisation", fig.fullwidth=TRUE, fig.height=5.5, fig.width=9.5, fig.align='center',fig.pos="H", warning=FALSE, message=FALSE, echo=FALSE}
load(file="predictionInSwitzerlandMAP.RData")
plots <- dfSwissMAP %>%
  dplyr::filter(Temperature %in% c(-15, 5, 25)) %>%
  group_by(Temperature) %>%
  mutate(pdf_1 = pdf_1 / mean(pdf_1)) %>%
  split(.$Temperature) %>%
  lapply(function(data) {
    ggplot(data) +
      geom_raster(mapping = aes(x = Longitude, y = Latitude, fill = pdf_1), alpha = 0.5) +
      theme_bw() +
      scale_fill_viridis(option = "viridis", direction = +1,
                         name = "Probability density",
                         guide = guide_colorbar(
                           direction = "horizontal",
                           barheight = unit(2, units = "mm"),
                           barwidth = unit(50, units = "mm"),
                           draw.ulim = FALSE,
                           title.position = 'top',
                           title.hjust = 0.5,
                           label.hjust = 0.5
                         )) +
      labs(
        title = paste0("Probability of the chunk\nknowing the temperature is ", 
                       unique(data$Temperature), "°C"),
        x = "Longitude",
        y = "Latitude"
      ) +
      theme(
        panel.grid = element_blank(),     # Remove grid lines
        axis.ticks.x = element_blank(),   # Remove x-axis ticks
        axis.text.x = element_blank(),    # Remove x-axis text
        axis.title.x = element_blank(),   # Remove x-axis label
        axis.ticks.y = element_blank(),   # Remove y-axis ticks
        axis.text.y = element_blank(),    # Remove y-axis text
        axis.title.y = element_blank(),   # Remove y-axis label
        legend.position = "bottom")
  })

# Arrange plots with cowplot
plot<- plot_grid(plotlist = plots, ncol = 3, align = 'hv')
# ggsave(plot, file="./Figures/invPb.png", 
#        width=9.5, height=3.75, scale=1/1.10)
# ggsave(file="./Figures/invPb.pdf", 
#        width=9.5, height=3.75, scale=1/1.10)
```

These results are consistent with Switzerland's diverse geography:

  * *Cold Temperatures (e.g., -15°C):* The SLGP modelling predominantly identifies locations in the Alps and at high altitudes, where cold conditions are common due to elevation. This aligns with our expectation, as the high Alpine summits and mountainous regions experience colder temperatures.

  * *Moderate Temperatures (e.g., 5°C):* The SLGP MAP estimator shows a broader range of possible locations, including the Swiss Plateau and parts of Ticino (center-south of Switzerland). Additionally, moderate temperatures are also observed in mountainous regions, provided they aren’t at very high altitudes.

  * *Warm Temperatures (e.g., 25°C):* The model highlights low-altitude areas like the Swiss Plateau and valleys in Ticino as likely locations for warmer temperatures.  The southern slopes of the Alps, such as those in Ticino, experience a warmer climate due to the influence of southern climate patterns. This analysis rules out higher mountainous areas, as such temperatures are unusual at high elevations.

This approach offers a sight into the potential of SLGP for solving stochastic inverse problems. 

## Probabilistic prediction of quantities of interest

```{r}
# Recombine chunks
data_chunks <- list()

for (i in 1:77) {  # Replace with actual number of chunks
  load(paste0("./SavedData/predictionInSwitzerlandMCMC_", i, ".RData"))
  data_chunks[[i]] <- temp
}

# Recombine all chunks into a single object if it's a data frame or list
dfSwissMCMC <- do.call("rbind", data_chunks)  # Adjust based on data structure
rm(data_chunks)


disc_long <- 100/diff(range_long)
disc_lat <- 100/diff(range_lat)

stations_discretized <- stations %>%
  mutate(Longitude=round(Longitude*(disc_long-1))/(disc_long-1),
         Latitude=round(Latitude*(disc_lat-1))/(disc_lat-1))%>%
  dplyr::select(Latitude, Longitude, Station) %>%
  data.frame() 

df_plot_meteo2 <- merge(dfSwissMCMC, stations_discretized, 
                        by=c("Latitude", "Longitude"), all.x=TRUE)
unique(df_plot_meteo2$Station)

gc()
df_plot_meteo2$subset2 <- abs((df_plot_meteo2$Latitude-range_lat[1])/diff(range_lat)+
                                1.125*(df_plot_meteo2$Longitude-range_long[1])/
                                diff(range_long)-0.86)<=0.03
df_plot_meteo2$subset1 <- abs((df_plot_meteo2$Latitude-range_lat[1])/diff(range_lat)+
                                1.125*(df_plot_meteo2$Longitude-range_long[1])/
                                diff(range_long)-0.86)<=0.005

plotmap <- switzerland +
  geom_segment(aes(x=0.175*diff(range_long)+range_long[1],
                   xend=0.68*diff(range_long)+range_long[1],
                   y=47.12,
                   yend=46.01), col="black", linewidth=2)+
  geom_segment(aes(x=0.175*diff(range_long)+range_long[1],
                   xend=0.68*diff(range_long)+range_long[1],
                   y=47.12,
                   yend=46.01), col="grey", lty=1)
plot(plotmap)

```

```{r}
# Extract the chunks on the slice and project them in 1D
df_plot_meteo2 <- subset(df_plot_meteo2, df_plot_meteo2$subset2)
df_plot_meteo2$Latitude <- (df_plot_meteo2$Latitude - range_lat[1])/diff(range_lat)
df_plot_meteo2$Longitude <- (df_plot_meteo2$Longitude - range_long[1])/diff(range_long)
# line y=-1.125 x+ 0.86
library(StereoMorph)
orth_vect <- orthogonalProjectionToLine(df_plot_meteo2[, c(1:2)], l1 = c(0, 0.86), 
                                        l2 = c(1, 0.86-1.125))
df_plot_meteo2$x1proj <- orth_vect[, 1]
df_plot_meteo2$x2proj <- orth_vect[, 2]
df_plot_meteo2$dproj <- sqrt((df_plot_meteo2$x1-df_plot_meteo2$x1proj)^2+
                               (df_plot_meteo2$x2-df_plot_meteo2$x2proj)^2)
df_plot_meteo2<- df_plot_meteo2%>%
  mutate(place_on_line = 1-(x1proj-min(x1proj))/diff(range(x1proj)))%>%
  group_by(dproj)

df_plot_meteo2 <-  df_plot_meteo2%>%
  dplyr::select(-x1proj, -x2proj)%>%
  mutate(Latitude=Latitude*diff(range_lat)+range_lat[1],
         Longitude=Longitude*diff(range_long)+range_long[1])%>%
  pivot_longer(-c("Latitude", "Longitude", "Altitude", "Temperature", "place_on_line", "dproj","subset1", "subset2", "Station"))%>%
  mutate(simu=substr(name, 5, 10),
         valuepdf=value) %>%
  group_by(Latitude, Longitude, Altitude, simu)%>%
  mutate(valuecdf=cumsum(value))%>%
  mutate(valuecdf=valuecdf-min(valuecdf))%>%
  mutate(valuecdf=valuecdf/max(valuecdf))%>%
  ungroup()%>%
  dplyr::select(-c("name", "value"))%>%
  data.frame()

df_plot_meteo2_summary <- df_plot_meteo2 %>%
  group_by(Latitude, Longitude, Altitude, simu)%>%
  summarise(place_on_line=mean(place_on_line),
            subset1 = median(subset1),
            subset2 = median(subset2),
            dproj = mean(dproj),
            mean = mean(Temperature*valuepdf),
            Station=ifelse(all(is.na(Station)), NA, unique(na.omit(Station))),
            q10 = Temperature[which.min(abs(valuecdf-0.1))],
            q20 = Temperature[which.min(abs(valuecdf-0.2))],
            q30 = Temperature[which.min(abs(valuecdf-0.3))],
            q40 = Temperature[which.min(abs(valuecdf-0.4))],
            q50 = Temperature[which.min(abs(valuecdf-0.5))],
            q60 = Temperature[which.min(abs(valuecdf-0.6))],
            q70 = Temperature[which.min(abs(valuecdf-0.7))],
            q80 = Temperature[which.min(abs(valuecdf-0.8))],
            q90 = Temperature[which.min(abs(valuecdf-0.9))],
            .groups="keep")%>%
  ungroup()%>%
  data.frame()

# Select the stations on this slice
stations_other <- subset(df_plot_meteo2_summary,
                         !is.na(df_plot_meteo2$Station))
stations_other <- dplyr::select(stations_other, -starts_with("pdf"))
stations_other<- stations_other%>%
  mutate(Latitude=Latitude*diff(range_lat)+range_lat[1],
         Longitude=Longitude*diff(range_long)+range_long[1])
```

We visualise the topographic profile of this slice, and the location of the stations alongside it.

```{r}
plot1 <- 
  df_plot_meteo2_summary %>%
  filter(subset1==1)%>%
  dplyr::select(-mean)%>%
  pivot_longer(starts_with("q"))%>%
  mutate(name=paste0(substr(name, 2, 3), "%"))%>%
  rename(`Quantile level`=name)%>%
  group_by(Latitude, Longitude, Altitude, place_on_line, `Quantile level`)%>%
  summarise(mean=mean(value),
            qL=quantile(value, 0.1),
            qH = quantile(value, 0.9),
            .groups="keep")%>%
  ggplot(aes(x=place_on_line, y=Altitude))+
  geom_ribbon(mapping=aes(ymin=0, ymax=Altitude), alpha=0.2, col="black", lty=1)+

  geom_label_repel(data=stations_other,
                   aes(label=Station),
                   size=3, alpha=0.9, 
                   point.padding = 0.5, 
                   box.padding = 0.5,    
                   segment.curvature = -1e-20)+
  theme_bw()+
  theme(legend.position="bottom", 
        legend.box = "horizontal")+
  ylab("Elevation above sea level [m]")+
  xlab("Position alongside the slice")
plot1
```

```{r}
plot2 <- 
  df_plot_meteo2_summary %>%
  filter(subset1==1)%>%
  dplyr::select(-mean)%>%
  pivot_longer(starts_with("q"))%>%
  mutate(name=paste0(substr(name, 2, 3), "%"))%>%
  rename(`Quantile level`=name)%>%
  group_by(Latitude, Longitude, Altitude, place_on_line, `Quantile level`)%>%
  summarise(mean=mean(value),
            qL=quantile(value, 0.1),
            qH = quantile(value, 0.9),
            .groups="keep")%>%
  ggplot(aes(x=place_on_line, col=`Quantile level`, fill=`Quantile level`))+
  geom_line(mapping=aes(y=mean))+
  geom_ribbon(mapping=aes(ymin=qL, ymax=qH), alpha=0.2, lty=2)+
  theme_bw()+
  theme(legend.position="bottom", 
        legend.box = "horizontal")+
  ylab("Temperature value [°C]")+
  xlab("Position alongside the slice")+
  geom_vline(xintercept =stations_other$place_on_line+
               c(-0.02, +0.01, +0.02, +0.01, 0, 0), lty=2)+
  geom_label(data=stations_other, mapping=aes(label=Station, 
                                              y=c(-22, -17, -22,-12,-17,-22), x=place_on_line), inherit.aes = FALSE)
plot2 


plot_grid <- grid.arrange(plotmap+ theme(aspect.ratio=0.5), 
                          plot1, plot2,
                          ncol=2, nrow = 2, 
                          widths = c(3, 3), heights = c(3, 4),
                          layout_matrix = rbind(c(1, 1),
                                                c(2, 3)),
                          respect=FALSE)
# ggsave(plot_grid, file="./Figures/slice_switzerland.png", 
#        width=9.5, height=5.5, scale=1.1)
# ggsave(plot_grid, file="./Figures/slice_switzerland.pdf", 
#        width=9.5, height=5.5, scale=1.1)
```



```{r eval=FALSE, include=FALSE}
load(file="predictionInSwitzerlandMCMC.RData")

library(readxl)
library(raster)
library(rgdal)
rel <- raster("../datasets/relief/DTM Switzerland, 50m, by Sonny/DTM Switzerland 50m.tif",
              crs="+proj=utm +zone=32 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs +type=crs")
# ,
# crs="+proj=somerc +lat_0=46.95240555555556 +lon_0=7.439583333333333 +k_0=1 +x_0=600000 +y_0=200000 +ellps=bessel +towgs84=674.374,15.056,405.346,0,0,0,0 +units=m +no_defs")
crs(rel)
rel <- projectRaster(rel, crs="+proj=longlat +datum=WGS84")
rel_spdf <- as(rel, "SpatialPixelsDataFrame")
rel <- as.data.frame(rel_spdf)


summary(rel)
colnames(rel) <- c("h", "long", "lat")
disc_long <- 101
disc_lat <- 101
rel2 <- rel
rel2$long <- round(rel2$long*(disc_long-1))/(disc_long-1)
rel2$lat <- round(rel2$lat*(disc_lat-1))/(disc_lat-1)
rel2 <- rel2 %>%
  group_by(long, lat) %>%
  summarise(h=median(h)) %>%
  data.frame()


world_map <- map_data("world", region="Switzerland")
rel2$long <- round(rel2$long*(disc_long-1))/(disc_long-1)
rel2$lat <- round(rel2$lat*(disc_lat-1))/(disc_lat-1)
# Plot beginning
switzerland <- ggplot() + 
  geom_raster(rel2, mapping=aes(x=long, y=lat, fill=h*0), fill="white") +
  geom_raster(rel2, mapping=aes(x=long, y=lat, fill=h), alpha=0.5) +
  theme_void()+
  theme(legend.position="bottom", 
        legend.box = "horizontal") +
  scale_fill_viridis(option = "turbo", direction = +1, 
                     name="Elevation [m]",
                     guide = guide_colorbar(
                       direction = "horizontal",
                       barheight = unit(2, units = "mm"),
                       barwidth = unit(50, units = "mm"),
                       draw.ulim = F,
                       title.position = 'top',
                       # some shifting around
                       title.hjust = 0.5,
                       label.hjust = 0.5
                     ))+ 
  xlab("Longitude") + ylab("Latitude") 
switzerland


disc_long <- 101
disc_lat <- 101
df2 <- data.frame(rel2)
df2$lat <- (df2$lat - range_lat[1])/diff(range_lat)
df2$long <- (df2$long - range_long[1])/diff(range_long)
df2$h <- c((df2$h - range_height[1])/diff(range_height))
rownames(df2) <- NULL
summary(df2)
df2$long <- round(df2$long*(disc_long-1))/(disc_long-1)
df2$lat <- round(df2$lat*(disc_lat-1))/(disc_lat-1)
df2 <- df2 %>%
  group_by(long, lat) %>%
  summarise(h=median(h), .groups="keep") %>%
  data.frame()
colnames(df2) <- c("x2", "x1", "x3")
df2 <- df2[, paste0("x", seq(3))]

stations_discretized <- stations_rescaled
stations_discretized$x1 <- round(stations_discretized$x1*100)/100
stations_discretized$x2 <- round(stations_discretized$x2*100)/100
stations_discretized$x3 <- NULL
stations_discretized$inBE <- NULL

df_plot_meteo <- evaluate_SLGP_grid(epsilon=Fit$Posterior1, 
                                    Xx=df2, 
                                    name_index, 
                                    lengthscale=res_opt$lengthscale,
                                    par_basis_functions=par_basis_functions)

df_plot_meteo2 <- merge(df_plot_meteo, stations_discretized, by=c("x1", "x2"), all.x=TRUE)
df_plot_meteo2$subset2 <- abs(df_plot_meteo2$x1+1.125*df_plot_meteo2$x2-0.86)<=0.03
df_plot_meteo2$subset1 <- abs(df_plot_meteo2$x1+1.125*df_plot_meteo2$x2-0.86)<=0.005
plotmap <- switzerland +
  # geom_abline(slope=-1.125*diff(range_lat)/diff(range_long), 
  #             intercept = diff(range_lat)*
  #               (0.86+1.125*(range_long[1])/diff(range_long))+
  #               range_lat[1])+
  geom_segment(aes(x=0.175*diff(range_long)+range_long[1],
                   xend=0.68*diff(range_long)+range_long[1],
                   y=47.12,
                   yend=46.01), col="black", size=2)+
  geom_segment(aes(x=0.175*diff(range_long)+range_long[1],
                   xend=0.68*diff(range_long)+range_long[1],
                   y=47.12,
                   yend=46.01), col="grey", lty=1)
plotmap

df_plot_meteo2 <- subset(df_plot_meteo2, df_plot_meteo2$subset2)
# line y=-1.125 x+ 0.86
library(StereoMorph)
orth_vect <- orthogonalProjectionToLine(df_plot_meteo2[, c(1:2)], l1 = c(0, 0.86), 
                                        l2 = c(1, 0.86-1.125))
df_plot_meteo2$x1proj <- orth_vect[, 1]
df_plot_meteo2$x2proj <- orth_vect[, 2]
df_plot_meteo2$dproj <- sqrt((df_plot_meteo2$x1-df_plot_meteo2$x1proj)^2+
                               (df_plot_meteo2$x2-df_plot_meteo2$x2proj)^2)
df_plot_meteo2<- df_plot_meteo2%>%
  mutate(place_on_line = 1-(x1proj-min(x1proj))/diff(range(x1proj)))%>%
  group_by(dproj)

df_plot_meteo2_summary <- df_plot_meteo2 %>%
  dplyr::select(-x1proj, -x2proj, -Station)%>%
  rename(lat=x1,
         long=x2, 
         alt=x3,
         temp=t)%>%
  mutate(temp=temp*diff(range_temp)+range_temp[1],
         lat=lat*diff(range_lat)+range_lat[1],
         long=long*diff(range_long)+range_long[1],
         alt=alt*diff(range_height)+range_height[1])%>%
  pivot_longer(-c("lat", "long", "alt", "temp", "place_on_line", "dproj","subset1", "subset2"))%>%
  mutate(value=ifelse(substr(name, 1, 4)=="pdf_", value/diff(range_temp), value))%>%
  mutate(simu=substr(name, 5, 10),
         name=substr(name, 1, 3))%>%
  group_by(lat, long, alt, simu)%>%
  summarise(place_on_line=mean(place_on_line),
            subset1 = median(subset1),
            subset2=median(subset2),
            dproj=mean(dproj),
            mean = mean(temp*value*(name=="pdf"))*2,
            q20 = temp[which.min(1e10*(name=="pdf")+abs(value-0.2))],
            q30 = temp[which.min(1e10*(name=="pdf")+abs(value-0.3))],
            q10 = temp[which.min(1e10*(name=="pdf")+abs(value-0.1))],
            q90 = temp[which.min(1e10*(name=="pdf")+abs(value-0.9))],
            q40 = temp[which.min(1e10*(name=="pdf")+abs(value-0.4))],
            q60 = temp[which.min(1e10*(name=="pdf")+abs(value-0.6))],
            q80 = temp[which.min(1e10*(name=="pdf")+abs(value-0.8))],
            q50 = temp[which.min(1e10*(name=="pdf")+abs(value-0.5))],
            q70 = temp[which.min(1e10*(name=="pdf")+abs(value-0.7))], 
            .groups="keep")%>%
  ungroup()%>%
  data.frame()
stations_other <- subset(df_plot_meteo2,
                         !is.na(df_plot_meteo2$Station)&
                           df_plot_meteo2$t==0)
stations_other <- dplyr::select(stations_other, -starts_with("pdf"))
stations_other <- dplyr::select(stations_other, -starts_with("cdf"))
stations_other<- stations_other%>%
  rename(lat=x1,
         long=x2, 
         alt=x3,
         temp=t)%>%
  mutate(temp=temp*diff(range_temp)+range_temp[1],
         lat=lat*diff(range_lat)+range_lat[1],
         long=long*diff(range_long)+range_long[1],
         alt=alt*diff(range_height)+range_height[1])

plot1 <- 
  df_plot_meteo2_summary %>%
  filter(subset1==1)%>%
  dplyr::select(-mean)%>%
  pivot_longer(starts_with("q"))%>%
  mutate(name=paste0(substr(name, 2, 3), "%"))%>%
  rename(`Quantile level`=name)%>%
  group_by(lat, long, alt, place_on_line, `Quantile level`)%>%
  summarise(mean=mean(value),
            qL=quantile(value, 0.1),
            qH = quantile(value, 0.9))%>%
  ggplot(aes(x=place_on_line, y=alt))+
  geom_ribbon(mapping=aes(ymin=0, ymax=alt), alpha=0.2, col="black", lty=1)+
  geom_label_repel(data=stations_other, mapping=aes(label=Station))+
  theme_bw()+
  theme(legend.position="bottom", 
        legend.box = "horizontal")+
  ylab("Elevation above sea level [m]")+
  xlab("Position alongside the slice")
# geom_vline(data=data.frame(place_on_line=stations_other$place_on_line+
#                              c(-0.02, +0.01, +0.02, +0.01, 0, 0),
#                            alt=stations_other$alt),
#            mapping=aes(xintercept=place_on_line))
plot1

plot2 <- 
  df_plot_meteo2_summary %>%
  filter(subset1==1)%>%
  dplyr::select(-mean)%>%
  pivot_longer(starts_with("q"))%>%
  mutate(name=paste0(substr(name, 2, 3), "%"))%>%
  rename(`Quantile level`=name)%>%
  group_by(lat, long, alt, place_on_line, `Quantile level`)%>%
  summarise(mean=mean(value),
            qL=quantile(value, 0.1),
            qH = quantile(value, 0.9))%>%
  ggplot(aes(x=place_on_line, col=`Quantile level`, fill=`Quantile level`))+
  geom_line(mapping=aes(y=mean))+
  geom_ribbon(mapping=aes(ymin=qL, ymax=qH), alpha=0.2, lty=2)+
  theme_bw()+
  theme(legend.position="bottom", 
        legend.box = "horizontal")+
  ylab("Temperature value [°C]")+
  xlab("Position alongside the slice")+
  geom_vline(xintercept =stations_other$place_on_line+
               c(-0.02, +0.01, +0.02, +0.01, 0, 0), lty=2)+
  geom_label(data=stations_other, mapping=aes(label=Station, 
                                              y=c(-22, -17, -22,-12,-17,-22), x=place_on_line), inherit.aes = FALSE)
plot2 


plot_grid <- grid.arrange(plotmap+ theme(aspect.ratio=0.5), 
                          plot1, plot2,
                          ncol=2, nrow = 2, 
                          widths = c(3, 3), heights = c(3, 4),
                          layout_matrix = rbind(c(1, 1),
                                                c(2, 3)),
                          respect=FALSE)
# ggsave(plot_grid, file="./Figures/slice_switzerland.png", 
#        width=9.5, height=5.5, scale=1.1)
# ggsave(plot_grid, file="./Figures/slice_switzerland.pdf", 
#        width=9.5, height=5.5, scale=1.1)

subset <- df_plot_meteo2$x1
df_plot_meteo_summary <- df_plot_meteo %>%
  rename(lat=x1,
         long=x2, 
         alt=x3,
         temp=t)%>%
  mutate(temp=temp*diff(range_temp)+range_temp[1],
         lat=lat*diff(range_lat)+range_lat[1],
         long=long*diff(range_long)+range_long[1],
         alt=alt*diff(range_height)+range_height[1])%>%
  pivot_longer(-c("lat", "long", "alt", "temp"))%>%
  mutate(value=ifelse(substr(name, 1, 4)=="pdf_", value/diff(range_temp), value))%>%
  mutate(simu=substr(name, 5, 10),
         name=substr(name, 1, 3))%>%
  group_by(lat, long, alt, simu)%>%
  summarise(mean = mean(temp*value*(name=="pdf"))*2,
            q50 = temp[which.min(1e10*(name=="pdf")+abs(value-0.5))],
            q10 = temp[which.min(1e10*(name=="pdf")+abs(value-0.1))],
            q90 = temp[which.min(1e10*(name=="pdf")+abs(value-0.9))],
            q25 = temp[which.min(1e10*(name=="pdf")+abs(value-0.25))],
            q75 = temp[which.min(1e10*(name=="pdf")+abs(value-0.75))],
            inv25 = value[which.min(abs(temp-25)+1e10*(name=="pdf"))],
            inv20 = value[which.min(abs(temp-20)+1e10*(name=="pdf"))],
            inv15 = value[which.min(abs(temp-15)+1e10*(name=="pdf"))],
            inv10 = value[which.min(abs(temp-10)+1e10*(name=="pdf"))],
            invminus10 = value[which.min(abs(temp+10)+1e10*(name=="pdf"))],
            inv5 = value[which.min(abs(temp-5)+1e10*(name=="pdf"))],
            invminus5 = value[which.min(abs(temp+5)+1e10*(name=="pdf"))],
            inv = value[which.min(abs(temp+0)+1e10*(name=="pdf"))], .groups="keep")%>%
  ungroup()%>%
  data.frame()

df_plot_meteo_summary <- df_plot_meteo_summary %>%
  ungroup()%>%
  pivot_longer(-c("lat", "long", "alt", "simu"))%>%
  group_by(lat, long, alt, name)%>%
  summarise(expectation=mean(value),
            sd=sd(value), .groups="keep")%>%
  ungroup()%>%
  rename(quantity=name)%>%
  pivot_longer(-c("lat", "long", "alt", "quantity"))%>%
  
  pivot_wider(names_from = quantity, values_from = value)%>%
  ungroup()%>%
  data.frame()
ind_exp <- df_plot_meteo_summary$name=="expectation"
plot1 <- ggplot(df_plot_meteo_summary[ind_exp, ],
                aes(x=long, y=lat, fill=q50))+
  geom_raster()+
  theme_void()+
  theme(legend.position="bottom", 
        legend.box = "horizontal") +
  scale_fill_viridis(option = "magma", direction = -1, 
                     name="Expected value [°C]",
                     guide = guide_colorbar(
                       direction = "horizontal",
                       barheight = unit(2, units = "mm"),
                       barwidth = unit(50, units = "mm"),
                       draw.ulim = F,
                       title.position = 'top',
                       # some shifting around
                       title.hjust = 0.5,
                       label.hjust = 0.5
                     ))+ 
  xlab("Longitude") + ylab("Latitude") 
plot2 <- ggplot(df_plot_meteo_summary[!ind_exp, ],
                aes(x=long, y=lat, fill=q50))+
  geom_raster()+
  theme_void()+
  theme(legend.position="bottom", 
        legend.box = "horizontal") +
  scale_fill_viridis(option = "magma", direction = -1, 
                     name="Standard deviation [°C]",
                     guide = guide_colorbar(
                       direction = "horizontal",
                       barheight = unit(2, units = "mm"),
                       barwidth = unit(50, units = "mm"),
                       draw.ulim = F,
                       title.position = 'top',
                       # some shifting around
                       title.hjust = 0.5,
                       label.hjust = 0.5
                     ))+ 
  xlab("Longitude") + ylab("Latitude") 
plot_grid <- grid.arrange(plot1, plot2, ncol=2)
# ggsave(plot_grid, file="./Figures/grid_about_q50.png", 
#        width=9, height=3.5, scale=1)
# ggsave(plot_grid, file="./Figures/grid_about_q50.pdf", 
#        width=9, height=3.5, scale=1)

plot1 <- ggplot(df_plot_meteo_summary[ind_exp, ],
                aes(x=long, y=lat, fill=mean))+
  geom_raster()+
  theme_void()+
  theme(legend.position="bottom", 
        legend.box = "horizontal") +
  scale_fill_viridis(option = "magma", direction = -1, 
                     name="Expected value [°C]",
                     guide = guide_colorbar(
                       direction = "horizontal",
                       barheight = unit(2, units = "mm"),
                       barwidth = unit(50, units = "mm"),
                       draw.ulim = F,
                       title.position = 'top',
                       # some shifting around
                       title.hjust = 0.5,
                       label.hjust = 0.5
                     ))+ 
  xlab("Longitude") + ylab("Latitude") 
plot2 <- ggplot(df_plot_meteo_summary[!ind_exp, ],
                aes(x=long, y=lat, fill=mean))+
  geom_raster()+
  theme_void()+
  theme(legend.position="bottom", 
        legend.box = "horizontal") +
  scale_fill_viridis(option = "magma", direction = -1, 
                     name="Standard deviation [°C]",
                     guide = guide_colorbar(
                       direction = "horizontal",
                       barheight = unit(2, units = "mm"),
                       barwidth = unit(50, units = "mm"),
                       draw.ulim = F,
                       title.position = 'top',
                       # some shifting around
                       title.hjust = 0.5,
                       label.hjust = 0.5
                     ))+ 
  xlab("Longitude") + ylab("Latitude") 
plot_grid <- grid.arrange(plot1, plot2, ncol=2)
# ggsave(plot_grid, file="./Figures/grid_about_mean.png", 
#        width=9, height=3.5, scale=1)
# ggsave(plot_grid, file="./Figures/grid_about_mean.pdf", 
#        width=9, height=3.5, scale=1)
```

